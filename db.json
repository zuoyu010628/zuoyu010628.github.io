{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/cactus/source/css/rtl.styl","path":"css/rtl.styl","modified":1,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","path":"lib/clipboard/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","path":"lib/vazir-font/Vazir-Regular.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","path":"lib/vazir-font/Vazir-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","path":"lib/vazir-font/Vazir-Regular.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","path":"lib/vazir-font/Vazir-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","path":"lib/vazir-font/Vazir-Variable.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","path":"lib/vazir-font/Vazir-Variable.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","path":"lib/vazir-font/Vazir-Variable.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","path":"lib/vazir-font/Vazir-Variable.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","path":"lib/font-awesome/webfonts/fa-v4compatibility.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","path":"lib/font-awesome/webfonts/fa-v4compatibility.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/C-11.md","hash":"f096789d584674f2bfa786a8ce58e78886c50de4","modified":1716274251262},{"_id":"source/_posts/websocket.md","hash":"d9996bc4ea9bd387b69fd63cb67448908334595b","modified":1719564460316},{"_id":"source/_posts/C-17.md","hash":"313a1c8cabfb643bd47a01338924e44030f19e54","modified":1719564456672},{"_id":"themes/cactus/.gitignore","hash":"72267ee409a324fc197c150b3c4bf28b87b709a8","modified":1723691943460},{"_id":"themes/cactus/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1723691943460},{"_id":"themes/cactus/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1723691943460},{"_id":"themes/cactus/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1723691943460},{"_id":"themes/cactus/README.md","hash":"c497023057269cc3a6c66e5a6f207625041e9bd7","modified":1723691943460},{"_id":"themes/cactus/_config.yml","hash":"cae317adc443f3f45297d5c22c32c39924652cf9","modified":1723691943460},{"_id":"themes/cactus/gulpfile.js","hash":"70d419549ba72e0906fd2fc8103701142eb883a7","modified":1723691943460},{"_id":"themes/cactus/package.json","hash":"dbb0a486006e7d4ecdb4b005b6a9b264b5d542dc","modified":1723691943464},{"_id":"themes/cactus/languages/ar.yml","hash":"81a88b0593fc89de3118d686681b1f69883c847b","modified":1723691943460},{"_id":"themes/cactus/languages/ca.yml","hash":"b79dd2c21dc6697c635e92db1f661a4b8d5d2305","modified":1723691943460},{"_id":"themes/cactus/languages/de.yml","hash":"43b2f4e078b042aaae0377a4235216a51ed82e0d","modified":1723691943460},{"_id":"themes/cactus/languages/default.yml","hash":"6a84970bf69c3e9490e5382747ca2b4c4b4dccde","modified":1723691943460},{"_id":"themes/cactus/languages/en.yml","hash":"6a84970bf69c3e9490e5382747ca2b4c4b4dccde","modified":1723691943460},{"_id":"themes/cactus/languages/es.yml","hash":"2b1fc8b0d636123e9ee39017fa20053bd1913a5a","modified":1723691943460},{"_id":"themes/cactus/languages/fa.yml","hash":"63f32e50953af1c4bd0308a4fca5862b5287c2cb","modified":1723691943460},{"_id":"themes/cactus/languages/fr.yml","hash":"5c07406998f19d219a5a7b65c0d88b6b023f85b2","modified":1723691943460},{"_id":"themes/cactus/languages/it.yml","hash":"62800bcae1f2d2454f87f4bcf4d7593848424f61","modified":1723691943460},{"_id":"themes/cactus/languages/kr.yml","hash":"651fb83991c91b13b53ed55740e5402cf0f1c5e8","modified":1723691943460},{"_id":"themes/cactus/languages/nl.yml","hash":"ac0573352ad2c737a7686bcca498b985e7bd6447","modified":1723691943460},{"_id":"themes/cactus/languages/pl.yml","hash":"8a2d6dc874d86c38d42c2c861c39590647b5d536","modified":1723691943460},{"_id":"themes/cactus/languages/pt-br.yml","hash":"4859aba788a050c2d5d0b997693b0c8c24b349f7","modified":1723691943460},{"_id":"themes/cactus/languages/ru.yml","hash":"81b57fcd1977ef534f4bf303dbc1b4710cc7f057","modified":1723691943460},{"_id":"themes/cactus/languages/tr.yml","hash":"43eb6f5abfb7f3d5a7a76af9f4f18c11182e6eb3","modified":1723691943460},{"_id":"themes/cactus/languages/ua.yml","hash":"d56eee90b599758c36e2b3437feb6515c0f512b9","modified":1723691943460},{"_id":"themes/cactus/languages/vi.yml","hash":"f84893c3ec3e45875c90069e14b17ed3016ed973","modified":1723691943460},{"_id":"themes/cactus/languages/zh-CN.yml","hash":"d016060817311addb4c528de440126b975038c31","modified":1723691943460},{"_id":"themes/cactus/languages/zh-TW.yml","hash":"3ee52bad37171900560d4082c2ceae25e6afddb3","modified":1723691943460},{"_id":"themes/cactus/layout/404.ejs","hash":"b911da998c160cceb8cd7c4dae709a1374ed2491","modified":1723691943460},{"_id":"themes/cactus/layout/archive.ejs","hash":"8e9bb1199694b229d2a3de1c3a55188a28e6f5e7","modified":1723691943464},{"_id":"themes/cactus/layout/index.ejs","hash":"fb73e020655ec4696eb7f91a350bf3b9c0fa2755","modified":1723691943464},{"_id":"themes/cactus/layout/layout.ejs","hash":"e03062a5a70d71dff9f09dd86769d1a13b33afd9","modified":1723691943464},{"_id":"themes/cactus/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1723691943464},{"_id":"themes/cactus/layout/post.ejs","hash":"f8eac342118298447ef38c21f9560a359e488395","modified":1723691943464},{"_id":"themes/cactus/scripts/cdn.js","hash":"887edec364d51efa7c524446483188c6ad05adaf","modified":1723691943464},{"_id":"themes/cactus/scripts/error_404.js","hash":"f83b290e47cb78a2754152fccc34e571a72087bd","modified":1723691943464},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1723691943464},{"_id":"themes/cactus/scripts/meta.js","hash":"654868666b6573b2cee7e750b47ad8a3c2ee13a0","modified":1723691943464},{"_id":"themes/cactus/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1723691943464},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"4e75035a427fd137ae7f12940209e8e97845df3b","modified":1723691943460},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"12fd63b51472c9c5b8b7d167eb1a96bf1d686c20","modified":1723691943460},{"_id":"themes/cactus/layout/_partial/google_analytics.ejs","hash":"64aeee0fdfc06207573ddbf8b91f6d3f007ccea9","modified":1723691943460},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"4709e17487315e8f0a5b38f0611f0244f16fdd87","modified":1723691943460},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"21d60f0bb82367cc2bee0c7eb3c06c7f5ab56a6d","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"247bf8ec39965fe07b52f5a3d04e02e0aaf2da57","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"9bbc0cf2dd0d7cdaafe827c3945a9bea1503da83","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"c6bc7e8a422c5bb57f88fed1d1b0694d03e24e74","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/umami_analytics.ejs","hash":"3e79be7343c4d0a5971d3aa659e3750672a91e72","modified":1723691943464},{"_id":"themes/cactus/source/css/_extend.styl","hash":"b6a4e5905a7515dda66919167531a5ab2b3d1fe2","modified":1723691943464},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"354809b5a64e8a47a66c66fd1a28ac597c1460a6","modified":1723691943464},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1723691943464},{"_id":"themes/cactus/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1723691943464},{"_id":"themes/cactus/source/css/_variables.styl","hash":"69d9c5e95edcaee5ccd8218262b989ce721cce79","modified":1723691943464},{"_id":"themes/cactus/source/css/rtl.styl","hash":"ff8700e1626feeb53d905a2df2777bda7d1eca50","modified":1723691943464},{"_id":"themes/cactus/source/css/style.styl","hash":"4ee0091bfa3cf43fa528d54df378f3d977257342","modified":1723691943464},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1723691943468},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1723691943468},{"_id":"themes/cactus/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1723691943468},{"_id":"themes/cactus/source/js/main.js","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1723691943468},{"_id":"themes/cactus/source/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1723691943468},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"54a590e39e2d6e9ee41b8a1423a7bc67ab03363d","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"5ee47fffaf428802cfe47dd2e6186c6bbff85067","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/category.ejs","hash":"aeb99694d8492d4fcda320493b259fb68bf21830","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"23770328c7d900ecc7fd87930dc24b095eb272ac","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"9a15a7c005cfe518fdc9ec61a5107c76012f49d0","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"80bd2afd49b296e6441ab977a0614add710c32a3","modified":1723691943464},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"b2a00781d1301ff4d362b5d2a97480052ee4cae1","modified":1723691943464},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"bc09f8777a6c99030da953dfdb84f793c5e4fd85","modified":1723691943464},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"9aa43b1f23d5d268dfa36bd942d6ce97b7677c4d","modified":1723691943464},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"d14ef1aa02d0895b6f9321ebfc23a1ec84b054b8","modified":1723691943464},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"88e93a9d3fe1d0270d65cabdeacc18bd94d45937","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1723691943464},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"31aef892437d5734a134c34f2a8a6610a8f671c3","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"258370d8ab98e63804ead9bc030f633ca97a1235","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"61c2c7c5f73a0022ec41830bea0812a97f522d7c","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"8ce12f14382b6d471e3fe1266573b34fa84deaa0","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"59c99f4ea3a73bf47ce030df166c5e33d5de31fb","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/tooltip.styl","hash":"2daff581ec3efaec840cbfdee512195919c32629","modified":1723691943464},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","hash":"9a7cb405f9beed005891587d41f76a0720893ffc","modified":1723691943468},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1723691943488},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1723691943488},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1723691943496},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"a1f36f9a3fd5ffcd832bf39e9402678978035d48","modified":1723691943464},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"0d2966c1d870392476864af8ee3ba312ba30cb82","modified":1723691943464},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"fb363d27cfdfe71a243fa2ac3dab2815232b9b7e","modified":1723691943472},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"67afa6237670ab99125056f2899129f22912dcf3","modified":1723691943472},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"a9d072aca9e0fadc2a7167671ce3d6b18d9cd2cc","modified":1723691943472},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"8f80d0bbe995f7fe92320fdaec10cd5ccd710a51","modified":1723691943472},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1723691943472},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1723691943472},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1723691943472},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1723691943488},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1723691943488},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1723691943488},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1723691943492},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1723691943496},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1723691943496},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","hash":"8c06d82739d14b094ff6d9036021a252bd1d985d","modified":1723691943468},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"4350f9ba93384634faf35f41c503c99c767f1069","modified":1723691943468},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f0982a77285d53653845b0a78170b4688db972f1","modified":1723691943468},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"6b99aa650bd12a36caa14e0127435d8f4cd3ba73","modified":1723691943472},{"_id":"themes/cactus/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1723691943468},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"20bd663830188cbadd2264e1daf9497c3ffc3621","modified":1723691943472},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1723691943480},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1723691943488},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1723691943488},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1723691943476},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1723691943476},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1723691943480},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1723691943484},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1723691943484},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1723691943488},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1723691943488},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1723691943488},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1723691943488},{"_id":"public/archives/index.html","hash":"35a3e35780b4753f6217fa7c0351bf234a9e5b07","modified":1723692000194},{"_id":"public/archives/2024/index.html","hash":"2d2f89e961c2af02a2b0719ec1fad5374117a921","modified":1723692000194},{"_id":"public/archives/2024/05/index.html","hash":"c704969a7b90cccdfa8fc47f7c419cd19ced7c15","modified":1723692000194},{"_id":"public/archives/2024/06/index.html","hash":"415d18b75871a190c939bb9ae273a64ac7caa11d","modified":1723692000194},{"_id":"public/index.html","hash":"2f17f53ab98b691f957c0e00a6a64a6e42e55484","modified":1723692000194},{"_id":"public/tags/C/index.html","hash":"4572dd21a8065b15015a4b467a2cbfb3cb3b038e","modified":1723692000194},{"_id":"public/tags/C-11/index.html","hash":"a3677886d0295bcbe098b94144a022fe56517258","modified":1723692000194},{"_id":"public/tags/C-17/index.html","hash":"d842d34e50729080dfa2730f12b18ac2b317e28d","modified":1723692000194},{"_id":"public/tags/计算机网络/index.html","hash":"881ac411566ef4575d23b99c945762577d086525","modified":1723692000194},{"_id":"public/404.html","hash":"0a486df5d04c2167bd314c6c1efccb33632503dc","modified":1723692000194},{"_id":"public/2024/06/27/websocket/index.html","hash":"81380ba2f80decf04cdc69b933011d82dcb5cae1","modified":1723692000194},{"_id":"public/2024/05/21/C-11/index.html","hash":"ccb6b59b4a5e2e05b30c1b2138dd85c6d0152b13","modified":1723692000194},{"_id":"public/2024/05/20/C-17/index.html","hash":"c0e4cb58949f6f2f97dda9793f0116d85ef8341e","modified":1723692000194},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1723692000194},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1723692000194},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"fb363d27cfdfe71a243fa2ac3dab2815232b9b7e","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"67afa6237670ab99125056f2899129f22912dcf3","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"a9d072aca9e0fadc2a7167671ce3d6b18d9cd2cc","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"8f80d0bbe995f7fe92320fdaec10cd5ccd710a51","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1723692000194},{"_id":"public/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"4350f9ba93384634faf35f41c503c99c767f1069","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f0982a77285d53653845b0a78170b4688db972f1","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"6b99aa650bd12a36caa14e0127435d8f4cd3ba73","modified":1723692000194},{"_id":"public/css/rtl.css","hash":"9589fac02a34fd9084f805f801889028756bbb65","modified":1723692000194},{"_id":"public/js/main.js","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1723692000194},{"_id":"public/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1723692000194},{"_id":"public/lib/clipboard/clipboard.min.js","hash":"9a7cb405f9beed005891587d41f76a0720893ffc","modified":1723692000194},{"_id":"public/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1723692000194},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1723692000194},{"_id":"public/css/style.css","hash":"775c8fa6860f020f1bd5ebdc2d8346998602138a","modified":1723692000194},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1723692000194},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1723692000194},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"20bd663830188cbadd2264e1daf9497c3ffc3621","modified":1723692000194},{"_id":"public/lib/jquery/jquery.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1723692000194},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"8c06d82739d14b094ff6d9036021a252bd1d985d","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1723692000194},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1723692000194}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"C++11新特性","date":"2024-05-21T08:53:57.000Z","_content":"\nc++11相比c++17就比较熟悉了，原因当然是实践的比较多，自然就熟悉了。本文还是介绍我比较熟悉和比较简单的特性，太过熟悉的，比如nullptr，我不会讲也没有讲的必要，全部特性参照[C++11 - cppreference.com](https://en.cppreference.com/w/cpp/11)。\n\n## Core language features\n\n### auto & decltype\n\n+ auto：让编译器在编译期就推导出变量的类型。\n\n  很好用的关键字，但是不能滥用，否则会影响代码可读性，比如int，double这种简单类型就不要使用，一些不关心其具体类型的变量（比如lambda表达式）或者复杂类型就使用auto。\n\n+ decltype：编译器推导表达式的类型。\n\n> 具体的推导规则看了就忘实在记不住。\n\n### default & delete & final & override & explicit\n\n+ default ： 使用默认的函数定义，只用用于特殊成员函数（构造，析构之类）。\n\n```c++\nstruct A {\n  A() = default;\n  int a;\n  A(int i) { a = i; }\n};\nint main() {\n    A a;\n    return 0;\n}\n```\n\n+ delete ：如果没有定义特殊成员函数，编译器期就会生成默认的特殊成员函数，delete可以阻止这种行为。\n\n```c++\n//禁止对象的拷贝与赋值\nstruct A {\n    A() = default;\n    A(const A&) = delete;\n    A& operator=(const A&) = delete;\n    int a;\n    A(int i) { a = i; }\n};\n\nint main() {\n    A a1;\n    A a2 = a1;  // 错误，拷贝构造函数被禁用\n    A a3;\n    a3 = a1;  // 错误，拷贝赋值操作符被禁用\n}\n```\n\n\n+ final ：用于指定虚函数不能被重写或者类不能被继承。\n\n```C++\n class ChildOfBase : public Base {\n private:\n   int dontChangeMe() const final { return 1; }\n };\n \n class BadChildOfChild : public ChildOfBase {\n   int dontChangeMe() const override;  //ERROR\n }\n```\n\n```c++\nclass DontDeriveFromMe final {\n   // ...\n };\n \n class Failure : public DontDeriveFromMe { //ERROR\n   // ...\n };\n```\n\n+ override：用于确保一个函数是虚函数且重写了基类的虚函数。\n\n```c++\nstruct Base {\n    virtual void func() {\n        cout << \"base\" << endl;\n    }\n};\n\nstruct Derived : public Base{\n    void func() override { // 确保func被重写\n        cout << \"derived\" << endl;\n    }\n\n    void fu() override { // error，基类没有fu()，不可以被重写\n        \n    }\n};\n```\n\n+ explicit：专门用来修饰构造函数，表示只能显示构造，不能被隐式转换。\n\n```c++\nstruct A {\n    explicit A(int value) {\n        cout << \"value\" << endl;\n    }\n};\n\nint main() {\n    A a = 1; // error，不可以隐式转换\n    A aa(2); // ok\n    return 0;\n}\n```\n\n### 委托构造函数 & 继承构造函数\n\n+ 委托构造函数：允许同一个类中的一个构造函数（委托构造函数）调用另一个构造函数（目标构造函数），即在委托构造函数的初始化列表调用目标构造函数，执行顺序是先目标构造函数再委托构造函数。委托构造函数可以减少代码重复，避免相同的构造逻辑写多次。\n\n```c++\nstruct A {\n    A(){}\n    A(int a) { a_ = a; }\n\n    A(int a, int b) : A(a) { b_ = b; }\n\n    A(int a, int b, int c) : A(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n```\n\n+ 继承构造函数：允许派生类可以使用基类的构造函数。\n\n```c++\nstruct Base {\n    Base() {}\n    Base(int a) { a_ = a; }\n\n    Base(int a, int b) : Base(a) { b_ = b; }\n\n    Base(int a, int b, int c) : Base(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n\nstruct Derived : Base {\n    using Base::Base;//继承构造函数\n};\n\nint main() {\n    Derived a(1, 2, 3);\n    return 0;\n}\n```\n\n### 静态断言（static_assert）\n\nc++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。\n\n```c++\nstatic_assert(true/false, message);\n```\n\n### enum class\n\n新增带作用域的枚举类型,普通的枚举可以自动转换为整型，且不同的枚举可以相互比较，以至于产生潜藏的bug，而带作用域的枚举就不会有这些问题。\n\n```c++\nenum class AColor {\n    kRed,\n    kGreen,\n    kBlue\n};\nenum class BColor {\n    kWhite,\n    kBlack,\n    kYellow\n};\n\n\nint main() {\n    if (AColor::kRed == BColor::kWhite) { // 编译失败\n        cout << \"red == white\" << endl;\n    }\n    return 0;\n}\n```\n\n所以一定要使用带作用域的枚举。\n\n### thread_local\n\n顾名思义，线程本地，被`thread_local`修饰的变量具有线程周期，每一个线程都拥有其只拥有一个该变量的独立实例。\n\n### attribute\n\n+ [[noreturn]]：表明一个函数一定不会返回，注意是不会返回，而不是没有返回值\n\n+ [[carries_dependency]]：看不懂\n\n  > 允许我们将dependency跨越函数进行传递，用于避免在弱一致性模型平台上产生不必要的内存栅栏导致代码效率降低。\n\n### 列表初始化(list initialization)\n\n在变量名后加上初始化列表来进行对象的初始化\n\n```c++\nint a{123};\nstd::string s{\"test\"}\n```\n\n**std::initializer_list**是实现列表初始化的关键，它可以接受任意长度的初始化列表，可以理解为存储特定类型的数组\n\n```c++\nvoid f(std::initializer_list<double> il);\n \nvoid g(float x)\n{\n   f({1, x, 3});\n}\n \nvoid h()\n{\n   f({1, 2, 3});\n}\n```\n\n### constexpr\n\nconstexpr修饰的是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理\n\n```c++\nconstexpr int func(int i) {\n    return i + 1;\n}\n\nint main() {\n    int i = 2;\n    func(i);// 普通函数\n    func(2);// 编译期间就会被计算出来\n}\n```\n\n### lambda表达式\n\n其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。\n\n```c++\nauto func = [capture] (params) opt -> ret { func_body; };\n```\n\nlambda表达式允许捕获一定范围内的变量，但是不推荐默认捕获，明确捕获的变量\n\n- []不捕获任何变量\n- [&]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用\n\n- [=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用\n- [=, &a]值捕获外部作用域所有变量，按引用捕获a变量\n\n- [a]只值捕获a变量，不捕获其它变量\n- [this]捕获当前类中的this指针\n\n## Other\n\n其他的如智能指针，左右值之类比较重要的，需要单独写一篇文章来介绍。","source":"_posts/C-11.md","raw":"---\ntitle: C++11新特性\ndate: 2024-05-21 16:53:57\ntags:\n- C++\n- C++11\n\n---\n\nc++11相比c++17就比较熟悉了，原因当然是实践的比较多，自然就熟悉了。本文还是介绍我比较熟悉和比较简单的特性，太过熟悉的，比如nullptr，我不会讲也没有讲的必要，全部特性参照[C++11 - cppreference.com](https://en.cppreference.com/w/cpp/11)。\n\n## Core language features\n\n### auto & decltype\n\n+ auto：让编译器在编译期就推导出变量的类型。\n\n  很好用的关键字，但是不能滥用，否则会影响代码可读性，比如int，double这种简单类型就不要使用，一些不关心其具体类型的变量（比如lambda表达式）或者复杂类型就使用auto。\n\n+ decltype：编译器推导表达式的类型。\n\n> 具体的推导规则看了就忘实在记不住。\n\n### default & delete & final & override & explicit\n\n+ default ： 使用默认的函数定义，只用用于特殊成员函数（构造，析构之类）。\n\n```c++\nstruct A {\n  A() = default;\n  int a;\n  A(int i) { a = i; }\n};\nint main() {\n    A a;\n    return 0;\n}\n```\n\n+ delete ：如果没有定义特殊成员函数，编译器期就会生成默认的特殊成员函数，delete可以阻止这种行为。\n\n```c++\n//禁止对象的拷贝与赋值\nstruct A {\n    A() = default;\n    A(const A&) = delete;\n    A& operator=(const A&) = delete;\n    int a;\n    A(int i) { a = i; }\n};\n\nint main() {\n    A a1;\n    A a2 = a1;  // 错误，拷贝构造函数被禁用\n    A a3;\n    a3 = a1;  // 错误，拷贝赋值操作符被禁用\n}\n```\n\n\n+ final ：用于指定虚函数不能被重写或者类不能被继承。\n\n```C++\n class ChildOfBase : public Base {\n private:\n   int dontChangeMe() const final { return 1; }\n };\n \n class BadChildOfChild : public ChildOfBase {\n   int dontChangeMe() const override;  //ERROR\n }\n```\n\n```c++\nclass DontDeriveFromMe final {\n   // ...\n };\n \n class Failure : public DontDeriveFromMe { //ERROR\n   // ...\n };\n```\n\n+ override：用于确保一个函数是虚函数且重写了基类的虚函数。\n\n```c++\nstruct Base {\n    virtual void func() {\n        cout << \"base\" << endl;\n    }\n};\n\nstruct Derived : public Base{\n    void func() override { // 确保func被重写\n        cout << \"derived\" << endl;\n    }\n\n    void fu() override { // error，基类没有fu()，不可以被重写\n        \n    }\n};\n```\n\n+ explicit：专门用来修饰构造函数，表示只能显示构造，不能被隐式转换。\n\n```c++\nstruct A {\n    explicit A(int value) {\n        cout << \"value\" << endl;\n    }\n};\n\nint main() {\n    A a = 1; // error，不可以隐式转换\n    A aa(2); // ok\n    return 0;\n}\n```\n\n### 委托构造函数 & 继承构造函数\n\n+ 委托构造函数：允许同一个类中的一个构造函数（委托构造函数）调用另一个构造函数（目标构造函数），即在委托构造函数的初始化列表调用目标构造函数，执行顺序是先目标构造函数再委托构造函数。委托构造函数可以减少代码重复，避免相同的构造逻辑写多次。\n\n```c++\nstruct A {\n    A(){}\n    A(int a) { a_ = a; }\n\n    A(int a, int b) : A(a) { b_ = b; }\n\n    A(int a, int b, int c) : A(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n```\n\n+ 继承构造函数：允许派生类可以使用基类的构造函数。\n\n```c++\nstruct Base {\n    Base() {}\n    Base(int a) { a_ = a; }\n\n    Base(int a, int b) : Base(a) { b_ = b; }\n\n    Base(int a, int b, int c) : Base(a, b) { c_ = c; }\n\n    int a_;\n    int b_;\n    int c_;\n};\n\nstruct Derived : Base {\n    using Base::Base;//继承构造函数\n};\n\nint main() {\n    Derived a(1, 2, 3);\n    return 0;\n}\n```\n\n### 静态断言（static_assert）\n\nc++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。\n\n```c++\nstatic_assert(true/false, message);\n```\n\n### enum class\n\n新增带作用域的枚举类型,普通的枚举可以自动转换为整型，且不同的枚举可以相互比较，以至于产生潜藏的bug，而带作用域的枚举就不会有这些问题。\n\n```c++\nenum class AColor {\n    kRed,\n    kGreen,\n    kBlue\n};\nenum class BColor {\n    kWhite,\n    kBlack,\n    kYellow\n};\n\n\nint main() {\n    if (AColor::kRed == BColor::kWhite) { // 编译失败\n        cout << \"red == white\" << endl;\n    }\n    return 0;\n}\n```\n\n所以一定要使用带作用域的枚举。\n\n### thread_local\n\n顾名思义，线程本地，被`thread_local`修饰的变量具有线程周期，每一个线程都拥有其只拥有一个该变量的独立实例。\n\n### attribute\n\n+ [[noreturn]]：表明一个函数一定不会返回，注意是不会返回，而不是没有返回值\n\n+ [[carries_dependency]]：看不懂\n\n  > 允许我们将dependency跨越函数进行传递，用于避免在弱一致性模型平台上产生不必要的内存栅栏导致代码效率降低。\n\n### 列表初始化(list initialization)\n\n在变量名后加上初始化列表来进行对象的初始化\n\n```c++\nint a{123};\nstd::string s{\"test\"}\n```\n\n**std::initializer_list**是实现列表初始化的关键，它可以接受任意长度的初始化列表，可以理解为存储特定类型的数组\n\n```c++\nvoid f(std::initializer_list<double> il);\n \nvoid g(float x)\n{\n   f({1, x, 3});\n}\n \nvoid h()\n{\n   f({1, 2, 3});\n}\n```\n\n### constexpr\n\nconstexpr修饰的是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理\n\n```c++\nconstexpr int func(int i) {\n    return i + 1;\n}\n\nint main() {\n    int i = 2;\n    func(i);// 普通函数\n    func(2);// 编译期间就会被计算出来\n}\n```\n\n### lambda表达式\n\n其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。\n\n```c++\nauto func = [capture] (params) opt -> ret { func_body; };\n```\n\nlambda表达式允许捕获一定范围内的变量，但是不推荐默认捕获，明确捕获的变量\n\n- []不捕获任何变量\n- [&]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用\n\n- [=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用\n- [=, &a]值捕获外部作用域所有变量，按引用捕获a变量\n\n- [a]只值捕获a变量，不捕获其它变量\n- [this]捕获当前类中的this指针\n\n## Other\n\n其他的如智能指针，左右值之类比较重要的，需要单独写一篇文章来介绍。","slug":"C-11","published":1,"updated":"2024-05-21T06:50:51.262Z","comments":1,"layout":"post","photos":[],"_id":"clzuppnmq0000ytpzd8vi8uqs","content":"<p>c++11相比c++17就比较熟悉了，原因当然是实践的比较多，自然就熟悉了。本文还是介绍我比较熟悉和比较简单的特性，太过熟悉的，比如nullptr，我不会讲也没有讲的必要，全部特性参照<a href=\"https://en.cppreference.com/w/cpp/11\">C++11 - cppreference.com</a>。</p>\n<h2 id=\"Core-language-features\"><a href=\"#Core-language-features\" class=\"headerlink\" title=\"Core language features\"></a>Core language features</h2><h3 id=\"auto-decltype\"><a href=\"#auto-decltype\" class=\"headerlink\" title=\"auto &amp; decltype\"></a>auto &amp; decltype</h3><ul>\n<li><p>auto：让编译器在编译期就推导出变量的类型。</p>\n<p>很好用的关键字，但是不能滥用，否则会影响代码可读性，比如int，double这种简单类型就不要使用，一些不关心其具体类型的变量（比如lambda表达式）或者复杂类型就使用auto。</p>\n</li>\n<li><p>decltype：编译器推导表达式的类型。</p>\n</li>\n</ul>\n<blockquote>\n<p>具体的推导规则看了就忘实在记不住。</p>\n</blockquote>\n<h3 id=\"default-delete-final-override-explicit\"><a href=\"#default-delete-final-override-explicit\" class=\"headerlink\" title=\"default &amp; delete &amp; final &amp; override &amp; explicit\"></a>default &amp; delete &amp; final &amp; override &amp; explicit</h3><ul>\n<li>default ： 使用默认的函数定义，只用用于特殊成员函数（构造，析构之类）。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>(<span class=\"type\">int</span> i) &#123; a = i; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>delete ：如果没有定义特殊成员函数，编译器期就会生成默认的特殊成员函数，delete可以阻止这种行为。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//禁止对象的拷贝与赋值</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">const</span> A&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    A&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> A&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> i) &#123; a = i; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a1;</span><br><span class=\"line\">    A a2 = a1;  <span class=\"comment\">// 错误，拷贝构造函数被禁用</span></span><br><span class=\"line\">    A a3;</span><br><span class=\"line\">    a3 = a1;  <span class=\"comment\">// 错误，拷贝赋值操作符被禁用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>final ：用于指定虚函数不能被重写或者类不能被继承。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ChildOfBase</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dontChangeMe</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">final</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BadChildOfChild</span> : <span class=\"keyword\">public</span> ChildOfBase &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dontChangeMe</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span></span>;  <span class=\"comment\">//ERROR</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DontDeriveFromMe</span> <span class=\"keyword\">final</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Failure</span> : <span class=\"keyword\">public</span> DontDeriveFromMe &#123; <span class=\"comment\">//ERROR</span></span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>override：用于确保一个函数是虚函数且重写了基类的虚函数。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"comment\">// 确保func被重写</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fu</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"comment\">// error，基类没有fu()，不可以被重写</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>explicit：专门用来修饰构造函数，表示只能显示构造，不能被隐式转换。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">A</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a = <span class=\"number\">1</span>; <span class=\"comment\">// error，不可以隐式转换</span></span><br><span class=\"line\">    <span class=\"function\">A <span class=\"title\">aa</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"委托构造函数-继承构造函数\"><a href=\"#委托构造函数-继承构造函数\" class=\"headerlink\" title=\"委托构造函数 &amp; 继承构造函数\"></a>委托构造函数 &amp; 继承构造函数</h3><ul>\n<li>委托构造函数：允许同一个类中的一个构造函数（委托构造函数）调用另一个构造函数（目标构造函数），即在委托构造函数的初始化列表调用目标构造函数，执行顺序是先目标构造函数再委托构造函数。委托构造函数可以减少代码重复，避免相同的构造逻辑写多次。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> a) &#123; a_ = a; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) : <span class=\"built_in\">A</span>(a) &#123; b_ = b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c) : <span class=\"built_in\">A</span>(a, b) &#123; c_ = c; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a_;</span><br><span class=\"line\">    <span class=\"type\">int</span> b_;</span><br><span class=\"line\">    <span class=\"type\">int</span> c_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>继承构造函数：允许派生类可以使用基类的构造函数。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> a) &#123; a_ = a; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) : <span class=\"built_in\">Base</span>(a) &#123; b_ = b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c) : <span class=\"built_in\">Base</span>(a, b) &#123; c_ = c; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a_;</span><br><span class=\"line\">    <span class=\"type\">int</span> b_;</span><br><span class=\"line\">    <span class=\"type\">int</span> c_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Derived</span> : Base &#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;<span class=\"comment\">//继承构造函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态断言（static-assert）\"><a href=\"#静态断言（static-assert）\" class=\"headerlink\" title=\"静态断言（static_assert）\"></a>静态断言（static_assert）</h3><p>c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>/<span class=\"literal\">false</span>, message);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"enum-class\"><a href=\"#enum-class\" class=\"headerlink\" title=\"enum class\"></a>enum class</h3><p>新增带作用域的枚举类型,普通的枚举可以自动转换为整型，且不同的枚举可以相互比较，以至于产生潜藏的bug，而带作用域的枚举就不会有这些问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">AColor</span> &#123;</span><br><span class=\"line\">    kRed,</span><br><span class=\"line\">    kGreen,</span><br><span class=\"line\">    kBlue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">BColor</span> &#123;</span><br><span class=\"line\">    kWhite,</span><br><span class=\"line\">    kBlack,</span><br><span class=\"line\">    kYellow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (AColor::kRed == BColor::kWhite) &#123; <span class=\"comment\">// 编译失败</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;red == white&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以一定要使用带作用域的枚举。</p>\n<h3 id=\"thread-local\"><a href=\"#thread-local\" class=\"headerlink\" title=\"thread_local\"></a>thread_local</h3><p>顾名思义，线程本地，被<code>thread_local</code>修饰的变量具有线程周期，每一个线程都拥有其只拥有一个该变量的独立实例。</p>\n<h3 id=\"attribute\"><a href=\"#attribute\" class=\"headerlink\" title=\"attribute\"></a>attribute</h3><ul>\n<li><p>[[noreturn]]：表明一个函数一定不会返回，注意是不会返回，而不是没有返回值</p>\n</li>\n<li><p>[[carries_dependency]]：看不懂</p>\n<blockquote>\n<p>允许我们将dependency跨越函数进行传递，用于避免在弱一致性模型平台上产生不必要的内存栅栏导致代码效率降低。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"列表初始化-list-initialization\"><a href=\"#列表初始化-list-initialization\" class=\"headerlink\" title=\"列表初始化(list initialization)\"></a>列表初始化(list initialization)</h3><p>在变量名后加上初始化列表来进行对象的初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a&#123;<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\">std::string s&#123;<span class=\"string\">&quot;test&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>std::initializer_list</strong>是实现列表初始化的关键，它可以接受任意长度的初始化列表，可以理解为存储特定类型的数组</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(std::initializer_list&lt;<span class=\"type\">double</span>&gt; il)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"type\">float</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">f</span>(&#123;<span class=\"number\">1</span>, x, <span class=\"number\">3</span>&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">h</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">f</span>(&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h3><p>constexpr修饰的是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(i);<span class=\"comment\">// 普通函数</span></span><br><span class=\"line\">    <span class=\"built_in\">func</span>(<span class=\"number\">2</span>);<span class=\"comment\">// 编译期间就会被计算出来</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h3><p>其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>lambda表达式允许捕获一定范围内的变量，但是不推荐默认捕获，明确捕获的变量</p>\n<ul>\n<li><p>[]不捕获任何变量</p>\n</li>\n<li><p>[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用</p>\n</li>\n<li><p>[&#x3D;]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用</p>\n</li>\n<li><p>[&#x3D;, &amp;a]值捕获外部作用域所有变量，按引用捕获a变量</p>\n</li>\n<li><p>[a]只值捕获a变量，不捕获其它变量</p>\n</li>\n<li><p>[this]捕获当前类中的this指针</p>\n</li>\n</ul>\n<h2 id=\"Other\"><a href=\"#Other\" class=\"headerlink\" title=\"Other\"></a>Other</h2><p>其他的如智能指针，左右值之类比较重要的，需要单独写一篇文章来介绍。</p>\n","length":3886,"excerpt":"","more":"<p>c++11相比c++17就比较熟悉了，原因当然是实践的比较多，自然就熟悉了。本文还是介绍我比较熟悉和比较简单的特性，太过熟悉的，比如nullptr，我不会讲也没有讲的必要，全部特性参照<a href=\"https://en.cppreference.com/w/cpp/11\">C++11 - cppreference.com</a>。</p>\n<h2 id=\"Core-language-features\"><a href=\"#Core-language-features\" class=\"headerlink\" title=\"Core language features\"></a>Core language features</h2><h3 id=\"auto-decltype\"><a href=\"#auto-decltype\" class=\"headerlink\" title=\"auto &amp; decltype\"></a>auto &amp; decltype</h3><ul>\n<li><p>auto：让编译器在编译期就推导出变量的类型。</p>\n<p>很好用的关键字，但是不能滥用，否则会影响代码可读性，比如int，double这种简单类型就不要使用，一些不关心其具体类型的变量（比如lambda表达式）或者复杂类型就使用auto。</p>\n</li>\n<li><p>decltype：编译器推导表达式的类型。</p>\n</li>\n</ul>\n<blockquote>\n<p>具体的推导规则看了就忘实在记不住。</p>\n</blockquote>\n<h3 id=\"default-delete-final-override-explicit\"><a href=\"#default-delete-final-override-explicit\" class=\"headerlink\" title=\"default &amp; delete &amp; final &amp; override &amp; explicit\"></a>default &amp; delete &amp; final &amp; override &amp; explicit</h3><ul>\n<li>default ： 使用默认的函数定义，只用用于特殊成员函数（构造，析构之类）。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">A</span>(<span class=\"type\">int</span> i) &#123; a = i; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>delete ：如果没有定义特殊成员函数，编译器期就会生成默认的特殊成员函数，delete可以阻止这种行为。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//禁止对象的拷贝与赋值</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">const</span> A&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    A&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> A&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> i) &#123; a = i; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a1;</span><br><span class=\"line\">    A a2 = a1;  <span class=\"comment\">// 错误，拷贝构造函数被禁用</span></span><br><span class=\"line\">    A a3;</span><br><span class=\"line\">    a3 = a1;  <span class=\"comment\">// 错误，拷贝赋值操作符被禁用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>final ：用于指定虚函数不能被重写或者类不能被继承。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ChildOfBase</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dontChangeMe</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">final</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BadChildOfChild</span> : <span class=\"keyword\">public</span> ChildOfBase &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dontChangeMe</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span></span>;  <span class=\"comment\">//ERROR</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DontDeriveFromMe</span> <span class=\"keyword\">final</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Failure</span> : <span class=\"keyword\">public</span> DontDeriveFromMe &#123; <span class=\"comment\">//ERROR</span></span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>override：用于确保一个函数是虚函数且重写了基类的虚函数。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"comment\">// 确保func被重写</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fu</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; <span class=\"comment\">// error，基类没有fu()，不可以被重写</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>explicit：专门用来修饰构造函数，表示只能显示构造，不能被隐式转换。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">A</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    A a = <span class=\"number\">1</span>; <span class=\"comment\">// error，不可以隐式转换</span></span><br><span class=\"line\">    <span class=\"function\">A <span class=\"title\">aa</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"委托构造函数-继承构造函数\"><a href=\"#委托构造函数-继承构造函数\" class=\"headerlink\" title=\"委托构造函数 &amp; 继承构造函数\"></a>委托构造函数 &amp; 继承构造函数</h3><ul>\n<li>委托构造函数：允许同一个类中的一个构造函数（委托构造函数）调用另一个构造函数（目标构造函数），即在委托构造函数的初始化列表调用目标构造函数，执行顺序是先目标构造函数再委托构造函数。委托构造函数可以减少代码重复，避免相同的构造逻辑写多次。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> a) &#123; a_ = a; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) : <span class=\"built_in\">A</span>(a) &#123; b_ = b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c) : <span class=\"built_in\">A</span>(a, b) &#123; c_ = c; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a_;</span><br><span class=\"line\">    <span class=\"type\">int</span> b_;</span><br><span class=\"line\">    <span class=\"type\">int</span> c_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>继承构造函数：允许派生类可以使用基类的构造函数。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> a) &#123; a_ = a; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) : <span class=\"built_in\">Base</span>(a) &#123; b_ = b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c) : <span class=\"built_in\">Base</span>(a, b) &#123; c_ = c; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a_;</span><br><span class=\"line\">    <span class=\"type\">int</span> b_;</span><br><span class=\"line\">    <span class=\"type\">int</span> c_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Derived</span> : Base &#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::Base;<span class=\"comment\">//继承构造函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Derived <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态断言（static-assert）\"><a href=\"#静态断言（static-assert）\" class=\"headerlink\" title=\"静态断言（static_assert）\"></a>静态断言（static_assert）</h3><p>c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">static_assert</span>(<span class=\"literal\">true</span>/<span class=\"literal\">false</span>, message);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"enum-class\"><a href=\"#enum-class\" class=\"headerlink\" title=\"enum class\"></a>enum class</h3><p>新增带作用域的枚举类型,普通的枚举可以自动转换为整型，且不同的枚举可以相互比较，以至于产生潜藏的bug，而带作用域的枚举就不会有这些问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">AColor</span> &#123;</span><br><span class=\"line\">    kRed,</span><br><span class=\"line\">    kGreen,</span><br><span class=\"line\">    kBlue</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">enum class</span> <span class=\"title class_\">BColor</span> &#123;</span><br><span class=\"line\">    kWhite,</span><br><span class=\"line\">    kBlack,</span><br><span class=\"line\">    kYellow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (AColor::kRed == BColor::kWhite) &#123; <span class=\"comment\">// 编译失败</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;red == white&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以一定要使用带作用域的枚举。</p>\n<h3 id=\"thread-local\"><a href=\"#thread-local\" class=\"headerlink\" title=\"thread_local\"></a>thread_local</h3><p>顾名思义，线程本地，被<code>thread_local</code>修饰的变量具有线程周期，每一个线程都拥有其只拥有一个该变量的独立实例。</p>\n<h3 id=\"attribute\"><a href=\"#attribute\" class=\"headerlink\" title=\"attribute\"></a>attribute</h3><ul>\n<li><p>[[noreturn]]：表明一个函数一定不会返回，注意是不会返回，而不是没有返回值</p>\n</li>\n<li><p>[[carries_dependency]]：看不懂</p>\n<blockquote>\n<p>允许我们将dependency跨越函数进行传递，用于避免在弱一致性模型平台上产生不必要的内存栅栏导致代码效率降低。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"列表初始化-list-initialization\"><a href=\"#列表初始化-list-initialization\" class=\"headerlink\" title=\"列表初始化(list initialization)\"></a>列表初始化(list initialization)</h3><p>在变量名后加上初始化列表来进行对象的初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a&#123;<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\">std::string s&#123;<span class=\"string\">&quot;test&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>std::initializer_list</strong>是实现列表初始化的关键，它可以接受任意长度的初始化列表，可以理解为存储特定类型的数组</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(std::initializer_list&lt;<span class=\"type\">double</span>&gt; il)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"type\">float</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">f</span>(&#123;<span class=\"number\">1</span>, x, <span class=\"number\">3</span>&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">h</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">f</span>(&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h3><p>constexpr修饰的是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(i);<span class=\"comment\">// 普通函数</span></span><br><span class=\"line\">    <span class=\"built_in\">func</span>(<span class=\"number\">2</span>);<span class=\"comment\">// 编译期间就会被计算出来</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h3><p>其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>lambda表达式允许捕获一定范围内的变量，但是不推荐默认捕获，明确捕获的变量</p>\n<ul>\n<li><p>[]不捕获任何变量</p>\n</li>\n<li><p>[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用</p>\n</li>\n<li><p>[&#x3D;]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用</p>\n</li>\n<li><p>[&#x3D;, &amp;a]值捕获外部作用域所有变量，按引用捕获a变量</p>\n</li>\n<li><p>[a]只值捕获a变量，不捕获其它变量</p>\n</li>\n<li><p>[this]捕获当前类中的this指针</p>\n</li>\n</ul>\n<h2 id=\"Other\"><a href=\"#Other\" class=\"headerlink\" title=\"Other\"></a>Other</h2><p>其他的如智能指针，左右值之类比较重要的，需要单独写一篇文章来介绍。</p>\n"},{"title":"C++17新特性","date":"2024-05-20T05:50:07.000Z","_content":"\n归纳总结一些常见的（我见过的）或比较好理解的（我能理解的）C++17的特性，具体的全部特性参考链接[C++17 - cppreference.com](https://en.cppreference.com/w/cpp/17)。\n\n## New language features\n\n### Variables\n#### 结构化绑定\n\n首先先举一个例子，在leetcode刷题看题解经常会遇到这种写法。\n\n```c++\nunordered_map<int, int> mp;\nfor (auto &[k , v] : mp) {\n    if (k == 1) {//获取值\n        v = 1;//修改值\n    }\n    ...\n}\n```\n\n其中的  `auto [k, v]`就是结构化绑定，通过结构化绑定，我们可以很方便地获取 `map`对应的值。\n\n除去 `map`之外，还可以应用于 `pair`,`tuple`，结构体和数组，如果加上引用，还可以修改对象的值。\n\n还有就是，可以实现自定义类的结构化绑定以及结构化绑定不能应用于constexpr（据说c++20可以），我不懂就简单提一下。\n\n#### if-switch 语句初始化\n\n举个例子，c++17前，\n\n```c++\nint a = getValue();\nif (a > 10) {\n    //to something\n}\n\nswitch(a) {\n    case 1:\n    default:\n}\n```\n\nc++17后。\n\n```c++\nif (int a = getValue();a > 10) {\n    //to something\n}\n\nswitch(int a = getValue();a) {\n    case 1:\n    default:\n}\n```\n\n#### 内联变量\n\n 在头文件里定义一个内联的变量或者对象，如果这个定义被多个编译单元使用，那么他们都指向同一个唯一的对象。\n\n```c++\n//header file\nclass MyClass\n{\n\tstatic inline std::string name = \"\"; // OK since C++17\n\t//...\n};\ninline MyClass myGlobalObj; // OK even if included/defined by multiple CPP files\n```\n\n引入的原因，首先是c++中，不允许在类中初始化非const静态成员；\n\n> 因为静态成员是属于类，而不属于某个对象，如果在类中初始化，会导致每个对象都包含该静态成员。\n\n其次是如果在被多个cpp引用的头文件中定义类结构之外的变量会导致这些cpp中都定义了这个变量，导致重定义变量。\n\n关于内联就可以再写一篇文章，这就是学习c++让我感到痛苦的地方，平常你轻视的地方，却蕴含着三言两语难以说清楚的门道。\n\n### Templates\n\n#### 类模版参数推导（CATD/class template argument deduction)\n\n```c++\n//before c++17\nstd::vector<FooBar<int, const char*>> obj{a, b, c}; \n//c++17\n std::vector obj{a, b, c};\n```\n\n### constexpr \n\n#### constexpr lambda表达式\n\nC++17允许lambda函数成为constexpr，如果它们满足条件，就可以在需要编译时评估的上下文中使用\n\n```C++\nconstexpr auto lambda = [](int x) { return x * 2; };\nstatic_assert(lambda(5) == 10);\n```\n\n#### 编译期if（compile-time if constexpr）\n\n`if constexpr`是编译期的判断语句\n\n```C++\n//不同输入类型转换为字符串\ntemplate <typename T>\nstd::string convert(T input) {\n    if constexpr (std::is_same_v<T, const char*> ||\n                  std::is_same_v<T, std::string>) {\n        return input;\n    } else {\n        return std::to_string(input);\n    }\n}\n```\n\n### Namespaces\n\n#### 简化的命名空间嵌套（simplified nested namespaces）\n```c++\nnamespace A {\n    namespace B {\n        namespace C {\n            void func();\n        }\n    }\n}\n\n// c++17，更方便更舒适\nnamespace A::B::C {\n    void func();)\n}\n```\n\n### __has_include预处理表达式\n\n用来判断是否有某个头文件，代码可能在不同编译器下工作，不同编译器的可用头文件有可能不同。\n\n### 新增Attribute\n\n首先  `Attribute`是一个关键字，用于指定一个函数、变量、类、模板或类型 trait 应该具有的特殊行为。\n\n#### [[fallthrough]]\n\n通常在使用 switch 语句时，如果case 后没有加break，编译器就会发出警告信息，在case处理部分添加这个属性，用于消除这个警告信息，表示这部分逻辑本意如此。此外该属性只能用在 switch 语句中。\n\n```c++\nswitch (i) {}\n    case 1:\n        xxx; // warning\n    case 2:\n        xxx; \n        [[fallthrough]];// 警告消除\n    case 3:\n        xxx;\n       break;\n}\n```\n\n#### [[nodiscard]]\n\n被此属性修饰的函数，其返回值不应该被丢弃，如果被丢弃编译器就会发出警告信息；如果是修饰的枚举或者类，那么在对应函数返回该类型的时候也不应该丢弃结果。\n\n```c++\n[[nodiscard]] int func();\nvoid F() {\n    func(); // warning 没有处理函数返回值\n}\n```\n\n#### [[maybe_unused]]\n\n通常如果声明了一个变量但是从来没有使用过，编译器就会发出警告信息，使用该属性之后，编译器就会认为是故意为之，从而不再发出警告。需要注意，这个声明不会影响编译器的优化逻辑，在编译优化阶段，无用的变量还是会被处理掉。\n\n### lambda通过*this捕获对象副本（lambda capture of *this）\n\n正常情况下，lambda捕获了this指针，如果this指向的对象析构了，而函数再被调用且访问了成员变量，就会有问题，结果往往是崩溃。\n\n这个新特性让你捕获*this，持有了对象的拷贝，从而避免了上述问题。\n\n```c++\nstruct A {\n    int a;\n    void func() {\n        auto f = [*this] { // 这里\n            cout << a << endl;\n        };\n        f();\n    }  \n};\n```\n\n## New library features\n\n### Utility types\n+ std::any适用于之前使用void*作为通用类型的场景。\n+ std::optional适用于之前使用nullptr代表失败状态的场景。\n+ std::variant适用于之前使用union的场景。\n#### std::any\n\n可以存储任意类型的单个值\n\n```c++\nint main() {\n    std::any a = std::make_any<int>(1);//使用std::make_any创建对象\n    cout << a.type().name() << \" \" << std::any_cast<int>(a) << endl;//使用std::any_cast获取值\n    a = 2.2f;\n    cout << a.type().name() << \" \" << std::any_cast<float>(a) << endl;\n    if (a.has_value()) {//使用has_value（）判断是否有值\n        cout << a.type().name();\n    }\n    a.reset();//销毁所含对象\n    if (a.has_value()) {\n        cout << a.type().name();//type()查询所含的类型，返回typeid\n    }\n    a = emplace<std::string>(\"a\");//使用emplace会销毁之前的对象，构造新的对象\n    return 0;\n}\n```\n\n#### std::optional\n\n见名知意，表示一个值可能存在，没有值就是默认的 std::nullopt\n\n```c++\nstd::optional<int> divide(int a, int b) {\n    if (b == 0) {\n        return std::nullopt;\n    } else {\n        return a / b;\n    }\n}\n```\n\n对 `std::optional`对象使用 `has_valut()`来判断是否有值，使用 `*`或者`value()`来取值\n\n#### std::variant\n类型安全的联合体（可以称之为变化体），功能上与union类似，但是更加高级。\n+ 类型安全，由于存储了内部的类型信息，所有可以进行安全的类型转换\n+ 可以存储复杂类型，union只能存储POD类型（Plain Old Date）\n### Memory management\n\n#### 共享指针支持动态数组（array support for std::shared_ptr）\n\n```C++\nstd::shared_ptr<uint8_t[]> sp(new uint8_t[extraDataLength_], [](uint8_t* ptr) { delete[] ptr; });\n```\n\n### Compile-time programming(to-do)\n\n### Algorithms\n\n#### 并行算法\n\nc++17支持STL并行执行，简单提一下，以std::sort为例\n\n```C++\nstd::sort(exe_policy, begin, end, comp);\n```\n\n可以添加如下三种的执行策略\n\n+ `std::execution::seq`（顺序执行）\n+ `std::execution::par`（并行执行）\n+ `std::execution::par_unseq`（并行和向量化执行）\n\n### Iterators and containers\n\n#### std::map/unordered_map [`try_emplace`](https://en.cppreference.com/w/cpp/container/map/try_emplace)\n\n向`std::map/unordered_map`中插入元素往往使用`emplace`,其操作是如果元素不存在就会插入元素，否则不插入，但是如果元素已经存在，此时仍会构造一次待插入的元素，在判断不需要插入后将该元素立刻析构，所以产生了额外的开销， `try_emplace`就避免了这种问题。\n\n### Others\n\n#### std::string_view\n\n通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。\n\n```c++\nvoid func(std::string_view stv) { cout << stv << endl; }\n\nint main(void) {\n    std::string str = \"Hello World\";\n    std::cout << str << std::endl;\n\n    std::string_view stv(str.c_str(), str.size());\n    cout << stv << endl;\n    func(stv);\n    return 0;\n}\n```\n\n#### std::shared_mutex\n\n\n\n\n\n","source":"_posts/C-17.md","raw":"---\ntitle: C++17新特性\ndate: 2024-05-20 13:50:07\ntags:\n- C++\n- C++17\n---\n\n归纳总结一些常见的（我见过的）或比较好理解的（我能理解的）C++17的特性，具体的全部特性参考链接[C++17 - cppreference.com](https://en.cppreference.com/w/cpp/17)。\n\n## New language features\n\n### Variables\n#### 结构化绑定\n\n首先先举一个例子，在leetcode刷题看题解经常会遇到这种写法。\n\n```c++\nunordered_map<int, int> mp;\nfor (auto &[k , v] : mp) {\n    if (k == 1) {//获取值\n        v = 1;//修改值\n    }\n    ...\n}\n```\n\n其中的  `auto [k, v]`就是结构化绑定，通过结构化绑定，我们可以很方便地获取 `map`对应的值。\n\n除去 `map`之外，还可以应用于 `pair`,`tuple`，结构体和数组，如果加上引用，还可以修改对象的值。\n\n还有就是，可以实现自定义类的结构化绑定以及结构化绑定不能应用于constexpr（据说c++20可以），我不懂就简单提一下。\n\n#### if-switch 语句初始化\n\n举个例子，c++17前，\n\n```c++\nint a = getValue();\nif (a > 10) {\n    //to something\n}\n\nswitch(a) {\n    case 1:\n    default:\n}\n```\n\nc++17后。\n\n```c++\nif (int a = getValue();a > 10) {\n    //to something\n}\n\nswitch(int a = getValue();a) {\n    case 1:\n    default:\n}\n```\n\n#### 内联变量\n\n 在头文件里定义一个内联的变量或者对象，如果这个定义被多个编译单元使用，那么他们都指向同一个唯一的对象。\n\n```c++\n//header file\nclass MyClass\n{\n\tstatic inline std::string name = \"\"; // OK since C++17\n\t//...\n};\ninline MyClass myGlobalObj; // OK even if included/defined by multiple CPP files\n```\n\n引入的原因，首先是c++中，不允许在类中初始化非const静态成员；\n\n> 因为静态成员是属于类，而不属于某个对象，如果在类中初始化，会导致每个对象都包含该静态成员。\n\n其次是如果在被多个cpp引用的头文件中定义类结构之外的变量会导致这些cpp中都定义了这个变量，导致重定义变量。\n\n关于内联就可以再写一篇文章，这就是学习c++让我感到痛苦的地方，平常你轻视的地方，却蕴含着三言两语难以说清楚的门道。\n\n### Templates\n\n#### 类模版参数推导（CATD/class template argument deduction)\n\n```c++\n//before c++17\nstd::vector<FooBar<int, const char*>> obj{a, b, c}; \n//c++17\n std::vector obj{a, b, c};\n```\n\n### constexpr \n\n#### constexpr lambda表达式\n\nC++17允许lambda函数成为constexpr，如果它们满足条件，就可以在需要编译时评估的上下文中使用\n\n```C++\nconstexpr auto lambda = [](int x) { return x * 2; };\nstatic_assert(lambda(5) == 10);\n```\n\n#### 编译期if（compile-time if constexpr）\n\n`if constexpr`是编译期的判断语句\n\n```C++\n//不同输入类型转换为字符串\ntemplate <typename T>\nstd::string convert(T input) {\n    if constexpr (std::is_same_v<T, const char*> ||\n                  std::is_same_v<T, std::string>) {\n        return input;\n    } else {\n        return std::to_string(input);\n    }\n}\n```\n\n### Namespaces\n\n#### 简化的命名空间嵌套（simplified nested namespaces）\n```c++\nnamespace A {\n    namespace B {\n        namespace C {\n            void func();\n        }\n    }\n}\n\n// c++17，更方便更舒适\nnamespace A::B::C {\n    void func();)\n}\n```\n\n### __has_include预处理表达式\n\n用来判断是否有某个头文件，代码可能在不同编译器下工作，不同编译器的可用头文件有可能不同。\n\n### 新增Attribute\n\n首先  `Attribute`是一个关键字，用于指定一个函数、变量、类、模板或类型 trait 应该具有的特殊行为。\n\n#### [[fallthrough]]\n\n通常在使用 switch 语句时，如果case 后没有加break，编译器就会发出警告信息，在case处理部分添加这个属性，用于消除这个警告信息，表示这部分逻辑本意如此。此外该属性只能用在 switch 语句中。\n\n```c++\nswitch (i) {}\n    case 1:\n        xxx; // warning\n    case 2:\n        xxx; \n        [[fallthrough]];// 警告消除\n    case 3:\n        xxx;\n       break;\n}\n```\n\n#### [[nodiscard]]\n\n被此属性修饰的函数，其返回值不应该被丢弃，如果被丢弃编译器就会发出警告信息；如果是修饰的枚举或者类，那么在对应函数返回该类型的时候也不应该丢弃结果。\n\n```c++\n[[nodiscard]] int func();\nvoid F() {\n    func(); // warning 没有处理函数返回值\n}\n```\n\n#### [[maybe_unused]]\n\n通常如果声明了一个变量但是从来没有使用过，编译器就会发出警告信息，使用该属性之后，编译器就会认为是故意为之，从而不再发出警告。需要注意，这个声明不会影响编译器的优化逻辑，在编译优化阶段，无用的变量还是会被处理掉。\n\n### lambda通过*this捕获对象副本（lambda capture of *this）\n\n正常情况下，lambda捕获了this指针，如果this指向的对象析构了，而函数再被调用且访问了成员变量，就会有问题，结果往往是崩溃。\n\n这个新特性让你捕获*this，持有了对象的拷贝，从而避免了上述问题。\n\n```c++\nstruct A {\n    int a;\n    void func() {\n        auto f = [*this] { // 这里\n            cout << a << endl;\n        };\n        f();\n    }  \n};\n```\n\n## New library features\n\n### Utility types\n+ std::any适用于之前使用void*作为通用类型的场景。\n+ std::optional适用于之前使用nullptr代表失败状态的场景。\n+ std::variant适用于之前使用union的场景。\n#### std::any\n\n可以存储任意类型的单个值\n\n```c++\nint main() {\n    std::any a = std::make_any<int>(1);//使用std::make_any创建对象\n    cout << a.type().name() << \" \" << std::any_cast<int>(a) << endl;//使用std::any_cast获取值\n    a = 2.2f;\n    cout << a.type().name() << \" \" << std::any_cast<float>(a) << endl;\n    if (a.has_value()) {//使用has_value（）判断是否有值\n        cout << a.type().name();\n    }\n    a.reset();//销毁所含对象\n    if (a.has_value()) {\n        cout << a.type().name();//type()查询所含的类型，返回typeid\n    }\n    a = emplace<std::string>(\"a\");//使用emplace会销毁之前的对象，构造新的对象\n    return 0;\n}\n```\n\n#### std::optional\n\n见名知意，表示一个值可能存在，没有值就是默认的 std::nullopt\n\n```c++\nstd::optional<int> divide(int a, int b) {\n    if (b == 0) {\n        return std::nullopt;\n    } else {\n        return a / b;\n    }\n}\n```\n\n对 `std::optional`对象使用 `has_valut()`来判断是否有值，使用 `*`或者`value()`来取值\n\n#### std::variant\n类型安全的联合体（可以称之为变化体），功能上与union类似，但是更加高级。\n+ 类型安全，由于存储了内部的类型信息，所有可以进行安全的类型转换\n+ 可以存储复杂类型，union只能存储POD类型（Plain Old Date）\n### Memory management\n\n#### 共享指针支持动态数组（array support for std::shared_ptr）\n\n```C++\nstd::shared_ptr<uint8_t[]> sp(new uint8_t[extraDataLength_], [](uint8_t* ptr) { delete[] ptr; });\n```\n\n### Compile-time programming(to-do)\n\n### Algorithms\n\n#### 并行算法\n\nc++17支持STL并行执行，简单提一下，以std::sort为例\n\n```C++\nstd::sort(exe_policy, begin, end, comp);\n```\n\n可以添加如下三种的执行策略\n\n+ `std::execution::seq`（顺序执行）\n+ `std::execution::par`（并行执行）\n+ `std::execution::par_unseq`（并行和向量化执行）\n\n### Iterators and containers\n\n#### std::map/unordered_map [`try_emplace`](https://en.cppreference.com/w/cpp/container/map/try_emplace)\n\n向`std::map/unordered_map`中插入元素往往使用`emplace`,其操作是如果元素不存在就会插入元素，否则不插入，但是如果元素已经存在，此时仍会构造一次待插入的元素，在判断不需要插入后将该元素立刻析构，所以产生了额外的开销， `try_emplace`就避免了这种问题。\n\n### Others\n\n#### std::string_view\n\n通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。\n\n```c++\nvoid func(std::string_view stv) { cout << stv << endl; }\n\nint main(void) {\n    std::string str = \"Hello World\";\n    std::cout << str << std::endl;\n\n    std::string_view stv(str.c_str(), str.size());\n    cout << stv << endl;\n    func(stv);\n    return 0;\n}\n```\n\n#### std::shared_mutex\n\n\n\n\n\n","slug":"C-17","published":1,"updated":"2024-06-28T08:47:36.672Z","comments":1,"layout":"post","photos":[],"_id":"clzuppnmt0001ytpzdag2cwcv","content":"<p>归纳总结一些常见的（我见过的）或比较好理解的（我能理解的）C++17的特性，具体的全部特性参考链接<a href=\"https://en.cppreference.com/w/cpp/17\">C++17 - cppreference.com</a>。</p>\n<h2 id=\"New-language-features\"><a href=\"#New-language-features\" class=\"headerlink\" title=\"New language features\"></a>New language features</h2><h3 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h3><h4 id=\"结构化绑定\"><a href=\"#结构化绑定\" class=\"headerlink\" title=\"结构化绑定\"></a>结构化绑定</h4><p>首先先举一个例子，在leetcode刷题看题解经常会遇到这种写法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;[k , v] : mp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//获取值</span></span><br><span class=\"line\">        v = <span class=\"number\">1</span>;<span class=\"comment\">//修改值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的  <code>auto [k, v]</code>就是结构化绑定，通过结构化绑定，我们可以很方便地获取 <code>map</code>对应的值。</p>\n<p>除去 <code>map</code>之外，还可以应用于 <code>pair</code>,<code>tuple</code>，结构体和数组，如果加上引用，还可以修改对象的值。</p>\n<p>还有就是，可以实现自定义类的结构化绑定以及结构化绑定不能应用于constexpr（据说c++20可以），我不懂就简单提一下。</p>\n<h4 id=\"if-switch-语句初始化\"><a href=\"#if-switch-语句初始化\" class=\"headerlink\" title=\"if-switch 语句初始化\"></a>if-switch 语句初始化</h4><p>举个例子，c++17前，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"built_in\">getValue</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//to something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>c++17后。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"type\">int</span> a = <span class=\"built_in\">getValue</span>();a &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//to something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(<span class=\"type\">int</span> a = <span class=\"built_in\">getValue</span>();a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内联变量\"><a href=\"#内联变量\" class=\"headerlink\" title=\"内联变量\"></a>内联变量</h4><p> 在头文件里定义一个内联的变量或者对象，如果这个定义被多个编译单元使用，那么他们都指向同一个唯一的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//header file</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"keyword\">inline</span> std::string name = <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// OK since C++17</span></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> MyClass myGlobalObj; <span class=\"comment\">// OK even if included/defined by multiple CPP files</span></span><br></pre></td></tr></table></figure>\n\n<p>引入的原因，首先是c++中，不允许在类中初始化非const静态成员；</p>\n<blockquote>\n<p>因为静态成员是属于类，而不属于某个对象，如果在类中初始化，会导致每个对象都包含该静态成员。</p>\n</blockquote>\n<p>其次是如果在被多个cpp引用的头文件中定义类结构之外的变量会导致这些cpp中都定义了这个变量，导致重定义变量。</p>\n<p>关于内联就可以再写一篇文章，这就是学习c++让我感到痛苦的地方，平常你轻视的地方，却蕴含着三言两语难以说清楚的门道。</p>\n<h3 id=\"Templates\"><a href=\"#Templates\" class=\"headerlink\" title=\"Templates\"></a>Templates</h3><h4 id=\"类模版参数推导（CATD-class-template-argument-deduction\"><a href=\"#类模版参数推导（CATD-class-template-argument-deduction\" class=\"headerlink\" title=\"类模版参数推导（CATD&#x2F;class template argument deduction)\"></a>类模版参数推导（CATD&#x2F;class template argument deduction)</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//before c++17</span></span><br><span class=\"line\">std::vector&lt;FooBar&lt;<span class=\"type\">int</span>, <span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;&gt; obj&#123;a, b, c&#125;; </span><br><span class=\"line\"><span class=\"comment\">//c++17</span></span><br><span class=\"line\"> std::vector obj&#123;a, b, c&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h3><h4 id=\"constexpr-lambda表达式\"><a href=\"#constexpr-lambda表达式\" class=\"headerlink\" title=\"constexpr lambda表达式\"></a>constexpr lambda表达式</h4><p>C++17允许lambda函数成为constexpr，如果它们满足条件，就可以在需要编译时评估的上下文中使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">auto</span> lambda = [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(<span class=\"built_in\">lambda</span>(<span class=\"number\">5</span>) == <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译期if（compile-time-if-constexpr）\"><a href=\"#编译期if（compile-time-if-constexpr）\" class=\"headerlink\" title=\"编译期if（compile-time if constexpr）\"></a>编译期if（compile-time if constexpr）</h4><p><code>if constexpr</code>是编译期的判断语句</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不同输入类型转换为字符串</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">convert</span><span class=\"params\">(T input)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(std::is_same_v&lt;T, <span class=\"type\">const</span> <span class=\"type\">char</span>*&gt; ||</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                  std::is_same_v&lt;T, std::string&gt;)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">to_string</span>(input);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Namespaces\"><a href=\"#Namespaces\" class=\"headerlink\" title=\"Namespaces\"></a>Namespaces</h3><h4 id=\"简化的命名空间嵌套（simplified-nested-namespaces）\"><a href=\"#简化的命名空间嵌套（simplified-nested-namespaces）\" class=\"headerlink\" title=\"简化的命名空间嵌套（simplified nested namespaces）\"></a>简化的命名空间嵌套（simplified nested namespaces）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> B &#123;</span><br><span class=\"line\">        <span class=\"keyword\">namespace</span> C &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// c++17，更方便更舒适</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> A::B::C &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"has-include预处理表达式\"><a href=\"#has-include预处理表达式\" class=\"headerlink\" title=\"__has_include预处理表达式\"></a>__has_include预处理表达式</h3><p>用来判断是否有某个头文件，代码可能在不同编译器下工作，不同编译器的可用头文件有可能不同。</p>\n<h3 id=\"新增Attribute\"><a href=\"#新增Attribute\" class=\"headerlink\" title=\"新增Attribute\"></a>新增Attribute</h3><p>首先  <code>Attribute</code>是一个关键字，用于指定一个函数、变量、类、模板或类型 trait 应该具有的特殊行为。</p>\n<h4 id=\"fallthrough\"><a href=\"#fallthrough\" class=\"headerlink\" title=\"[[fallthrough]]\"></a>[[fallthrough]]</h4><p>通常在使用 switch 语句时，如果case 后没有加break，编译器就会发出警告信息，在case处理部分添加这个属性，用于消除这个警告信息，表示这部分逻辑本意如此。此外该属性只能用在 switch 语句中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (i) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        xxx; <span class=\"comment\">// warning</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        xxx; </span><br><span class=\"line\">        [[fallthrough]];<span class=\"comment\">// 警告消除</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        xxx;</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"nodiscard\"><a href=\"#nodiscard\" class=\"headerlink\" title=\"[[nodiscard]]\"></a>[[nodiscard]]</h4><p>被此属性修饰的函数，其返回值不应该被丢弃，如果被丢弃编译器就会发出警告信息；如果是修饰的枚举或者类，那么在对应函数返回该类型的时候也不应该丢弃结果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[nodiscard]] <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">F</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(); <span class=\"comment\">// warning 没有处理函数返回值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"maybe-unused\"><a href=\"#maybe-unused\" class=\"headerlink\" title=\"[[maybe_unused]]\"></a>[[maybe_unused]]</h4><p>通常如果声明了一个变量但是从来没有使用过，编译器就会发出警告信息，使用该属性之后，编译器就会认为是故意为之，从而不再发出警告。需要注意，这个声明不会影响编译器的优化逻辑，在编译优化阶段，无用的变量还是会被处理掉。</p>\n<h3 id=\"lambda通过-this捕获对象副本（lambda-capture-of-this）\"><a href=\"#lambda通过-this捕获对象副本（lambda-capture-of-this）\" class=\"headerlink\" title=\"lambda通过*this捕获对象副本（lambda capture of *this）\"></a>lambda通过*this捕获对象副本（lambda capture of *this）</h3><p>正常情况下，lambda捕获了this指针，如果this指向的对象析构了，而函数再被调用且访问了成员变量，就会有问题，结果往往是崩溃。</p>\n<p>这个新特性让你捕获*this，持有了对象的拷贝，从而避免了上述问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> f = [*<span class=\"keyword\">this</span>] &#123; <span class=\"comment\">// 这里</span></span><br><span class=\"line\">            cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">f</span>();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"New-library-features\"><a href=\"#New-library-features\" class=\"headerlink\" title=\"New library features\"></a>New library features</h2><h3 id=\"Utility-types\"><a href=\"#Utility-types\" class=\"headerlink\" title=\"Utility types\"></a>Utility types</h3><ul>\n<li>std::any适用于之前使用void*作为通用类型的场景。</li>\n<li>std::optional适用于之前使用nullptr代表失败状态的场景。</li>\n<li>std::variant适用于之前使用union的场景。</li>\n</ul>\n<h4 id=\"std-any\"><a href=\"#std-any\" class=\"headerlink\" title=\"std::any\"></a>std::any</h4><p>可以存储任意类型的单个值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::any a = std::<span class=\"built_in\">make_any</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">1</span>);<span class=\"comment\">//使用std::make_any创建对象</span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; std::<span class=\"built_in\">any_cast</span>&lt;<span class=\"type\">int</span>&gt;(a) &lt;&lt; endl;<span class=\"comment\">//使用std::any_cast获取值</span></span><br><span class=\"line\">    a = <span class=\"number\">2.2f</span>;</span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; std::<span class=\"built_in\">any_cast</span>&lt;<span class=\"type\">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.<span class=\"built_in\">has_value</span>()) &#123;<span class=\"comment\">//使用has_value（）判断是否有值</span></span><br><span class=\"line\">        cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a.<span class=\"built_in\">reset</span>();<span class=\"comment\">//销毁所含对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.<span class=\"built_in\">has_value</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>();<span class=\"comment\">//type()查询所含的类型，返回typeid</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a = <span class=\"built_in\">emplace</span>&lt;std::string&gt;(<span class=\"string\">&quot;a&quot;</span>);<span class=\"comment\">//使用emplace会销毁之前的对象，构造新的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-optional\"><a href=\"#std-optional\" class=\"headerlink\" title=\"std::optional\"></a>std::optional</h4><p>见名知意，表示一个值可能存在，没有值就是默认的 std::nullopt</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">divide</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"literal\">nullopt</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a / b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对 <code>std::optional</code>对象使用 <code>has_valut()</code>来判断是否有值，使用 <code>*</code>或者<code>value()</code>来取值</p>\n<h4 id=\"std-variant\"><a href=\"#std-variant\" class=\"headerlink\" title=\"std::variant\"></a>std::variant</h4><p>类型安全的联合体（可以称之为变化体），功能上与union类似，但是更加高级。</p>\n<ul>\n<li>类型安全，由于存储了内部的类型信息，所有可以进行安全的类型转换</li>\n<li>可以存储复杂类型，union只能存储POD类型（Plain Old Date）</li>\n</ul>\n<h3 id=\"Memory-management\"><a href=\"#Memory-management\" class=\"headerlink\" title=\"Memory management\"></a>Memory management</h3><h4 id=\"共享指针支持动态数组（array-support-for-std-shared-ptr）\"><a href=\"#共享指针支持动态数组（array-support-for-std-shared-ptr）\" class=\"headerlink\" title=\"共享指针支持动态数组（array support for std::shared_ptr）\"></a>共享指针支持动态数组（array support for std::shared_ptr）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">uint8_t</span>[]&gt; <span class=\"title\">sp</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">uint8_t</span>[extraDataLength_], [](<span class=\"type\">uint8_t</span>* ptr) &#123; <span class=\"keyword\">delete</span>[] ptr; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Compile-time-programming-to-do\"><a href=\"#Compile-time-programming-to-do\" class=\"headerlink\" title=\"Compile-time programming(to-do)\"></a>Compile-time programming(to-do)</h3><h3 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h3><h4 id=\"并行算法\"><a href=\"#并行算法\" class=\"headerlink\" title=\"并行算法\"></a>并行算法</h4><p>c++17支持STL并行执行，简单提一下，以std::sort为例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">sort</span>(exe_policy, begin, end, comp);</span><br></pre></td></tr></table></figure>\n\n<p>可以添加如下三种的执行策略</p>\n<ul>\n<li><code>std::execution::seq</code>（顺序执行）</li>\n<li><code>std::execution::par</code>（并行执行）</li>\n<li><code>std::execution::par_unseq</code>（并行和向量化执行）</li>\n</ul>\n<h3 id=\"Iterators-and-containers\"><a href=\"#Iterators-and-containers\" class=\"headerlink\" title=\"Iterators and containers\"></a>Iterators and containers</h3><h4 id=\"std-map-unordered-map-try-emplace\"><a href=\"#std-map-unordered-map-try-emplace\" class=\"headerlink\" title=\"std::map&#x2F;unordered_map try_emplace\"></a>std::map&#x2F;unordered_map <a href=\"https://en.cppreference.com/w/cpp/container/map/try_emplace\"><code>try_emplace</code></a></h4><p>向<code>std::map/unordered_map</code>中插入元素往往使用<code>emplace</code>,其操作是如果元素不存在就会插入元素，否则不插入，但是如果元素已经存在，此时仍会构造一次待插入的元素，在判断不需要插入后将该元素立刻析构，所以产生了额外的开销， <code>try_emplace</code>就避免了这种问题。</p>\n<h3 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h3><h4 id=\"std-string-view\"><a href=\"#std-string-view\" class=\"headerlink\" title=\"std::string_view\"></a>std::string_view</h4><p>通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(std::string_view stv)</span> </span>&#123; cout &lt;&lt; stv &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    std::string str = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::string_view <span class=\"title\">stv</span><span class=\"params\">(str.c_str(), str.size())</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; stv &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(stv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-shared-mutex\"><a href=\"#std-shared-mutex\" class=\"headerlink\" title=\"std::shared_mutex\"></a>std::shared_mutex</h4>","length":4828,"excerpt":"","more":"<p>归纳总结一些常见的（我见过的）或比较好理解的（我能理解的）C++17的特性，具体的全部特性参考链接<a href=\"https://en.cppreference.com/w/cpp/17\">C++17 - cppreference.com</a>。</p>\n<h2 id=\"New-language-features\"><a href=\"#New-language-features\" class=\"headerlink\" title=\"New language features\"></a>New language features</h2><h3 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h3><h4 id=\"结构化绑定\"><a href=\"#结构化绑定\" class=\"headerlink\" title=\"结构化绑定\"></a>结构化绑定</h4><p>首先先举一个例子，在leetcode刷题看题解经常会遇到这种写法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;[k , v] : mp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//获取值</span></span><br><span class=\"line\">        v = <span class=\"number\">1</span>;<span class=\"comment\">//修改值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的  <code>auto [k, v]</code>就是结构化绑定，通过结构化绑定，我们可以很方便地获取 <code>map</code>对应的值。</p>\n<p>除去 <code>map</code>之外，还可以应用于 <code>pair</code>,<code>tuple</code>，结构体和数组，如果加上引用，还可以修改对象的值。</p>\n<p>还有就是，可以实现自定义类的结构化绑定以及结构化绑定不能应用于constexpr（据说c++20可以），我不懂就简单提一下。</p>\n<h4 id=\"if-switch-语句初始化\"><a href=\"#if-switch-语句初始化\" class=\"headerlink\" title=\"if-switch 语句初始化\"></a>if-switch 语句初始化</h4><p>举个例子，c++17前，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"built_in\">getValue</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//to something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>c++17后。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"type\">int</span> a = <span class=\"built_in\">getValue</span>();a &gt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//to something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(<span class=\"type\">int</span> a = <span class=\"built_in\">getValue</span>();a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内联变量\"><a href=\"#内联变量\" class=\"headerlink\" title=\"内联变量\"></a>内联变量</h4><p> 在头文件里定义一个内联的变量或者对象，如果这个定义被多个编译单元使用，那么他们都指向同一个唯一的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//header file</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"keyword\">inline</span> std::string name = <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// OK since C++17</span></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> MyClass myGlobalObj; <span class=\"comment\">// OK even if included/defined by multiple CPP files</span></span><br></pre></td></tr></table></figure>\n\n<p>引入的原因，首先是c++中，不允许在类中初始化非const静态成员；</p>\n<blockquote>\n<p>因为静态成员是属于类，而不属于某个对象，如果在类中初始化，会导致每个对象都包含该静态成员。</p>\n</blockquote>\n<p>其次是如果在被多个cpp引用的头文件中定义类结构之外的变量会导致这些cpp中都定义了这个变量，导致重定义变量。</p>\n<p>关于内联就可以再写一篇文章，这就是学习c++让我感到痛苦的地方，平常你轻视的地方，却蕴含着三言两语难以说清楚的门道。</p>\n<h3 id=\"Templates\"><a href=\"#Templates\" class=\"headerlink\" title=\"Templates\"></a>Templates</h3><h4 id=\"类模版参数推导（CATD-class-template-argument-deduction\"><a href=\"#类模版参数推导（CATD-class-template-argument-deduction\" class=\"headerlink\" title=\"类模版参数推导（CATD&#x2F;class template argument deduction)\"></a>类模版参数推导（CATD&#x2F;class template argument deduction)</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//before c++17</span></span><br><span class=\"line\">std::vector&lt;FooBar&lt;<span class=\"type\">int</span>, <span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;&gt; obj&#123;a, b, c&#125;; </span><br><span class=\"line\"><span class=\"comment\">//c++17</span></span><br><span class=\"line\"> std::vector obj&#123;a, b, c&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h3><h4 id=\"constexpr-lambda表达式\"><a href=\"#constexpr-lambda表达式\" class=\"headerlink\" title=\"constexpr lambda表达式\"></a>constexpr lambda表达式</h4><p>C++17允许lambda函数成为constexpr，如果它们满足条件，就可以在需要编译时评估的上下文中使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">auto</span> lambda = [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(<span class=\"built_in\">lambda</span>(<span class=\"number\">5</span>) == <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译期if（compile-time-if-constexpr）\"><a href=\"#编译期if（compile-time-if-constexpr）\" class=\"headerlink\" title=\"编译期if（compile-time if constexpr）\"></a>编译期if（compile-time if constexpr）</h4><p><code>if constexpr</code>是编译期的判断语句</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不同输入类型转换为字符串</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">convert</span><span class=\"params\">(T input)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">if</span> <span class=\"title\">constexpr</span> <span class=\"params\">(std::is_same_v&lt;T, <span class=\"type\">const</span> <span class=\"type\">char</span>*&gt; ||</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                  std::is_same_v&lt;T, std::string&gt;)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"built_in\">to_string</span>(input);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Namespaces\"><a href=\"#Namespaces\" class=\"headerlink\" title=\"Namespaces\"></a>Namespaces</h3><h4 id=\"简化的命名空间嵌套（simplified-nested-namespaces）\"><a href=\"#简化的命名空间嵌套（simplified-nested-namespaces）\" class=\"headerlink\" title=\"简化的命名空间嵌套（simplified nested namespaces）\"></a>简化的命名空间嵌套（simplified nested namespaces）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> B &#123;</span><br><span class=\"line\">        <span class=\"keyword\">namespace</span> C &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// c++17，更方便更舒适</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> A::B::C &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"has-include预处理表达式\"><a href=\"#has-include预处理表达式\" class=\"headerlink\" title=\"__has_include预处理表达式\"></a>__has_include预处理表达式</h3><p>用来判断是否有某个头文件，代码可能在不同编译器下工作，不同编译器的可用头文件有可能不同。</p>\n<h3 id=\"新增Attribute\"><a href=\"#新增Attribute\" class=\"headerlink\" title=\"新增Attribute\"></a>新增Attribute</h3><p>首先  <code>Attribute</code>是一个关键字，用于指定一个函数、变量、类、模板或类型 trait 应该具有的特殊行为。</p>\n<h4 id=\"fallthrough\"><a href=\"#fallthrough\" class=\"headerlink\" title=\"[[fallthrough]]\"></a>[[fallthrough]]</h4><p>通常在使用 switch 语句时，如果case 后没有加break，编译器就会发出警告信息，在case处理部分添加这个属性，用于消除这个警告信息，表示这部分逻辑本意如此。此外该属性只能用在 switch 语句中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (i) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        xxx; <span class=\"comment\">// warning</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        xxx; </span><br><span class=\"line\">        [[fallthrough]];<span class=\"comment\">// 警告消除</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        xxx;</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"nodiscard\"><a href=\"#nodiscard\" class=\"headerlink\" title=\"[[nodiscard]]\"></a>[[nodiscard]]</h4><p>被此属性修饰的函数，其返回值不应该被丢弃，如果被丢弃编译器就会发出警告信息；如果是修饰的枚举或者类，那么在对应函数返回该类型的时候也不应该丢弃结果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[nodiscard]] <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">F</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(); <span class=\"comment\">// warning 没有处理函数返回值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"maybe-unused\"><a href=\"#maybe-unused\" class=\"headerlink\" title=\"[[maybe_unused]]\"></a>[[maybe_unused]]</h4><p>通常如果声明了一个变量但是从来没有使用过，编译器就会发出警告信息，使用该属性之后，编译器就会认为是故意为之，从而不再发出警告。需要注意，这个声明不会影响编译器的优化逻辑，在编译优化阶段，无用的变量还是会被处理掉。</p>\n<h3 id=\"lambda通过-this捕获对象副本（lambda-capture-of-this）\"><a href=\"#lambda通过-this捕获对象副本（lambda-capture-of-this）\" class=\"headerlink\" title=\"lambda通过*this捕获对象副本（lambda capture of *this）\"></a>lambda通过*this捕获对象副本（lambda capture of *this）</h3><p>正常情况下，lambda捕获了this指针，如果this指向的对象析构了，而函数再被调用且访问了成员变量，就会有问题，结果往往是崩溃。</p>\n<p>这个新特性让你捕获*this，持有了对象的拷贝，从而避免了上述问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> f = [*<span class=\"keyword\">this</span>] &#123; <span class=\"comment\">// 这里</span></span><br><span class=\"line\">            cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">f</span>();</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"New-library-features\"><a href=\"#New-library-features\" class=\"headerlink\" title=\"New library features\"></a>New library features</h2><h3 id=\"Utility-types\"><a href=\"#Utility-types\" class=\"headerlink\" title=\"Utility types\"></a>Utility types</h3><ul>\n<li>std::any适用于之前使用void*作为通用类型的场景。</li>\n<li>std::optional适用于之前使用nullptr代表失败状态的场景。</li>\n<li>std::variant适用于之前使用union的场景。</li>\n</ul>\n<h4 id=\"std-any\"><a href=\"#std-any\" class=\"headerlink\" title=\"std::any\"></a>std::any</h4><p>可以存储任意类型的单个值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::any a = std::<span class=\"built_in\">make_any</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">1</span>);<span class=\"comment\">//使用std::make_any创建对象</span></span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; std::<span class=\"built_in\">any_cast</span>&lt;<span class=\"type\">int</span>&gt;(a) &lt;&lt; endl;<span class=\"comment\">//使用std::any_cast获取值</span></span><br><span class=\"line\">    a = <span class=\"number\">2.2f</span>;</span><br><span class=\"line\">    cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; std::<span class=\"built_in\">any_cast</span>&lt;<span class=\"type\">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.<span class=\"built_in\">has_value</span>()) &#123;<span class=\"comment\">//使用has_value（）判断是否有值</span></span><br><span class=\"line\">        cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a.<span class=\"built_in\">reset</span>();<span class=\"comment\">//销毁所含对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.<span class=\"built_in\">has_value</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; a.<span class=\"built_in\">type</span>().<span class=\"built_in\">name</span>();<span class=\"comment\">//type()查询所含的类型，返回typeid</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a = <span class=\"built_in\">emplace</span>&lt;std::string&gt;(<span class=\"string\">&quot;a&quot;</span>);<span class=\"comment\">//使用emplace会销毁之前的对象，构造新的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-optional\"><a href=\"#std-optional\" class=\"headerlink\" title=\"std::optional\"></a>std::optional</h4><p>见名知意，表示一个值可能存在，没有值就是默认的 std::nullopt</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">divide</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::<span class=\"literal\">nullopt</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a / b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对 <code>std::optional</code>对象使用 <code>has_valut()</code>来判断是否有值，使用 <code>*</code>或者<code>value()</code>来取值</p>\n<h4 id=\"std-variant\"><a href=\"#std-variant\" class=\"headerlink\" title=\"std::variant\"></a>std::variant</h4><p>类型安全的联合体（可以称之为变化体），功能上与union类似，但是更加高级。</p>\n<ul>\n<li>类型安全，由于存储了内部的类型信息，所有可以进行安全的类型转换</li>\n<li>可以存储复杂类型，union只能存储POD类型（Plain Old Date）</li>\n</ul>\n<h3 id=\"Memory-management\"><a href=\"#Memory-management\" class=\"headerlink\" title=\"Memory management\"></a>Memory management</h3><h4 id=\"共享指针支持动态数组（array-support-for-std-shared-ptr）\"><a href=\"#共享指针支持动态数组（array-support-for-std-shared-ptr）\" class=\"headerlink\" title=\"共享指针支持动态数组（array support for std::shared_ptr）\"></a>共享指针支持动态数组（array support for std::shared_ptr）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">uint8_t</span>[]&gt; <span class=\"title\">sp</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">uint8_t</span>[extraDataLength_], [](<span class=\"type\">uint8_t</span>* ptr) &#123; <span class=\"keyword\">delete</span>[] ptr; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Compile-time-programming-to-do\"><a href=\"#Compile-time-programming-to-do\" class=\"headerlink\" title=\"Compile-time programming(to-do)\"></a>Compile-time programming(to-do)</h3><h3 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h3><h4 id=\"并行算法\"><a href=\"#并行算法\" class=\"headerlink\" title=\"并行算法\"></a>并行算法</h4><p>c++17支持STL并行执行，简单提一下，以std::sort为例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">sort</span>(exe_policy, begin, end, comp);</span><br></pre></td></tr></table></figure>\n\n<p>可以添加如下三种的执行策略</p>\n<ul>\n<li><code>std::execution::seq</code>（顺序执行）</li>\n<li><code>std::execution::par</code>（并行执行）</li>\n<li><code>std::execution::par_unseq</code>（并行和向量化执行）</li>\n</ul>\n<h3 id=\"Iterators-and-containers\"><a href=\"#Iterators-and-containers\" class=\"headerlink\" title=\"Iterators and containers\"></a>Iterators and containers</h3><h4 id=\"std-map-unordered-map-try-emplace\"><a href=\"#std-map-unordered-map-try-emplace\" class=\"headerlink\" title=\"std::map&#x2F;unordered_map try_emplace\"></a>std::map&#x2F;unordered_map <a href=\"https://en.cppreference.com/w/cpp/container/map/try_emplace\"><code>try_emplace</code></a></h4><p>向<code>std::map/unordered_map</code>中插入元素往往使用<code>emplace</code>,其操作是如果元素不存在就会插入元素，否则不插入，但是如果元素已经存在，此时仍会构造一次待插入的元素，在判断不需要插入后将该元素立刻析构，所以产生了额外的开销， <code>try_emplace</code>就避免了这种问题。</p>\n<h3 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h3><h4 id=\"std-string-view\"><a href=\"#std-string-view\" class=\"headerlink\" title=\"std::string_view\"></a>std::string_view</h4><p>通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(std::string_view stv)</span> </span>&#123; cout &lt;&lt; stv &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    std::string str = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::string_view <span class=\"title\">stv</span><span class=\"params\">(str.c_str(), str.size())</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; stv &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(stv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-shared-mutex\"><a href=\"#std-shared-mutex\" class=\"headerlink\" title=\"std::shared_mutex\"></a>std::shared_mutex</h4>"},{"title":"从Websocket到内网穿透工具","date":"2024-06-27T05:39:11.000Z","_content":"\n最近工作上接触到了Websocket这个东西，由此引发了一系列的问题，写篇文章记录一下涉及的技术。\n\n## 为什么有Websocket？\n\n初见Websocket可能会联想到socket套接字，用我看到文章里的说法来解释两者的关系，大概就是雷锋和雷锋塔的关系，两者几乎没有关系。\n\n其实Wesocket是一个协议，属于应用层，提到应用层协议首先想到的是HTTP，对于我来说，我就只知道HTTP这一个应用层协议，既然有了HTTP，为什么还需要Websocket呢？\n\n因为HTTP有一个缺陷，通信只能由客户端发起。\n\n客户端发送请求后，服务器才能给客户端响应消息，这种单向性导致如果客户端要持续获得服务器的状态变化，就得每隔一段时间向服务器发送请求，这种方式称作轮询。\n\n轮询的弊端显而易见，需要额外的资源来进行轮询，即使服务器状态没有发生变化。\n\n众所周知，HTTP是基于TCP的，而TCP是全双工的，但HTTP是半双工的，这是因为HTTP起初是为看网页文本的场景设计的，没有考虑客户端和服务器之间需要大量互发数据。\n\n为了支持这种场景，就有了Websocket。\n\n## 什么是Websocket?\n\n基于TCP的应用层协议，支持全双工通信，协议标识符是`ws`(加密的话是`wss`)。\n\n```\nws://example.com:80/some/path\n```\n\n其报文结构我就不细说（不太关心，也不太了解），可以讲讲连接建立的方式。\n\n首先肯定是通过TCP三次握手建立连接，然后使用HTTP协议进行通信，如果想要建立Websocket通信，在这次HTTP通信中，就会带上特殊header头，接着就会升级到Websocket协议。\n\n```\nConnection: Upgrade\nUpgrade: WebSocket\nSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n //随机生成的 base64 码\n```\n\n## 如何搭建一个Websocket服务器\n\n工作需要，需要搭建一个Websocket服务器，在GPT帮助下也是易如反掌。\n\n1. 安装Node.js\n\n   ```bash\n   sudo apt update\n   sudo apt install nodejs npm\n   ```\n\n2. 创建服务器工程\n\n   ```bash\n   mkdir websocket-server\n   cd websocket-server\n   npm init -y\n   ```\n\n3. 安装ws库\n\n   ```bash\n   npm install ws\n   ```\n\n4. 创建服务器文件\n\n   在你的项目目录中创建一个名为 server.js 的文件，并添加以下代码：\n\n   ```js\n   const WebSocket = require('ws');\n   const wss = new WebSocket.Server({ host: 'localhost', port: 8080 });\n   wss.on('connection', function connection(ws) {\n   console.log('Client connected');\n   ws.on('message', function incoming(message) {\n   console.log('received: %s', message);\n   // Echo the message back to the client\n   ws.send(`Echo: ${message}`);\n   });\n   ws.on('close', function close() {\n   console.log('Client disconnected');\n   });\n   });\n   console.log('WebSocket server is running');\n   ```\n\n5. 运行服务器\n\n   ```bash\n   node server.js\n   ```\n\n   现在，你的WebSocket服务器应该在端口8080上运行。你可以使用任何支持WebSocket的客户端来连 接到这个服务器，例如WebSocket客户端或者浏览器。\n\n## 如何在公网上访问本地Websocket服务器\n\n使用上述流程搭建的服务器是在本地的8080端口上，如何让其他人也能访问到你的服务器呢？\n\n当然可以搭建一个公网服务器，但是为了工作还要付出额外开销是不可能的，于是可以采用内网穿透的方式来解决这个问题。\n\n> 内网穿透，也称为NAT穿透，是一种网络技术，它允许位于私有网络（内网）中的计算机或设备上的服务可以被外部网络（如互联网）上的其他计算机访问。这通常用于绕过NAT（网络地址转换）和防火墙的限制，因为大多数家庭和小型办公室网络都使用NAT来共享一个公共IP地址。\n\n我们可以使用 `localtunnel `工具来实现内网穿透。\n\n```bash\nnpm i -g localtunnel\nlt -p 8080\n```\n\n-p 参数后面跟着你的本地服务器端口，运行后，会分配一个随机唯一的公网URL，如果想要固定的 URL，请使用 -s 参数，后面跟着你设置的域名。\n\n```bash\nlt -p 8080 -s forwstest\n```\n\nGPT提示我说，这样方式暴露的服务器的安全性没法得到保障，很有可能被人反向工具，只建议测试使用。\n\n### 参考\n\n[3.9 既然有 HTTP 协议，为什么还要有 WebSocket？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/2_http/http_websocket.html#使用-http-不断轮询)\n\n[WebSocket 教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n\n[Localtunnel ~ Expose yourself to the world](https://localtunnel.github.io/www/)","source":"_posts/websocket.md","raw":"---\ntitle: 从Websocket到内网穿透工具\ndate: 2024-06-27 13:39:11\ntags: 计算机网络\n---\n\n最近工作上接触到了Websocket这个东西，由此引发了一系列的问题，写篇文章记录一下涉及的技术。\n\n## 为什么有Websocket？\n\n初见Websocket可能会联想到socket套接字，用我看到文章里的说法来解释两者的关系，大概就是雷锋和雷锋塔的关系，两者几乎没有关系。\n\n其实Wesocket是一个协议，属于应用层，提到应用层协议首先想到的是HTTP，对于我来说，我就只知道HTTP这一个应用层协议，既然有了HTTP，为什么还需要Websocket呢？\n\n因为HTTP有一个缺陷，通信只能由客户端发起。\n\n客户端发送请求后，服务器才能给客户端响应消息，这种单向性导致如果客户端要持续获得服务器的状态变化，就得每隔一段时间向服务器发送请求，这种方式称作轮询。\n\n轮询的弊端显而易见，需要额外的资源来进行轮询，即使服务器状态没有发生变化。\n\n众所周知，HTTP是基于TCP的，而TCP是全双工的，但HTTP是半双工的，这是因为HTTP起初是为看网页文本的场景设计的，没有考虑客户端和服务器之间需要大量互发数据。\n\n为了支持这种场景，就有了Websocket。\n\n## 什么是Websocket?\n\n基于TCP的应用层协议，支持全双工通信，协议标识符是`ws`(加密的话是`wss`)。\n\n```\nws://example.com:80/some/path\n```\n\n其报文结构我就不细说（不太关心，也不太了解），可以讲讲连接建立的方式。\n\n首先肯定是通过TCP三次握手建立连接，然后使用HTTP协议进行通信，如果想要建立Websocket通信，在这次HTTP通信中，就会带上特殊header头，接着就会升级到Websocket协议。\n\n```\nConnection: Upgrade\nUpgrade: WebSocket\nSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n //随机生成的 base64 码\n```\n\n## 如何搭建一个Websocket服务器\n\n工作需要，需要搭建一个Websocket服务器，在GPT帮助下也是易如反掌。\n\n1. 安装Node.js\n\n   ```bash\n   sudo apt update\n   sudo apt install nodejs npm\n   ```\n\n2. 创建服务器工程\n\n   ```bash\n   mkdir websocket-server\n   cd websocket-server\n   npm init -y\n   ```\n\n3. 安装ws库\n\n   ```bash\n   npm install ws\n   ```\n\n4. 创建服务器文件\n\n   在你的项目目录中创建一个名为 server.js 的文件，并添加以下代码：\n\n   ```js\n   const WebSocket = require('ws');\n   const wss = new WebSocket.Server({ host: 'localhost', port: 8080 });\n   wss.on('connection', function connection(ws) {\n   console.log('Client connected');\n   ws.on('message', function incoming(message) {\n   console.log('received: %s', message);\n   // Echo the message back to the client\n   ws.send(`Echo: ${message}`);\n   });\n   ws.on('close', function close() {\n   console.log('Client disconnected');\n   });\n   });\n   console.log('WebSocket server is running');\n   ```\n\n5. 运行服务器\n\n   ```bash\n   node server.js\n   ```\n\n   现在，你的WebSocket服务器应该在端口8080上运行。你可以使用任何支持WebSocket的客户端来连 接到这个服务器，例如WebSocket客户端或者浏览器。\n\n## 如何在公网上访问本地Websocket服务器\n\n使用上述流程搭建的服务器是在本地的8080端口上，如何让其他人也能访问到你的服务器呢？\n\n当然可以搭建一个公网服务器，但是为了工作还要付出额外开销是不可能的，于是可以采用内网穿透的方式来解决这个问题。\n\n> 内网穿透，也称为NAT穿透，是一种网络技术，它允许位于私有网络（内网）中的计算机或设备上的服务可以被外部网络（如互联网）上的其他计算机访问。这通常用于绕过NAT（网络地址转换）和防火墙的限制，因为大多数家庭和小型办公室网络都使用NAT来共享一个公共IP地址。\n\n我们可以使用 `localtunnel `工具来实现内网穿透。\n\n```bash\nnpm i -g localtunnel\nlt -p 8080\n```\n\n-p 参数后面跟着你的本地服务器端口，运行后，会分配一个随机唯一的公网URL，如果想要固定的 URL，请使用 -s 参数，后面跟着你设置的域名。\n\n```bash\nlt -p 8080 -s forwstest\n```\n\nGPT提示我说，这样方式暴露的服务器的安全性没法得到保障，很有可能被人反向工具，只建议测试使用。\n\n### 参考\n\n[3.9 既然有 HTTP 协议，为什么还要有 WebSocket？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/2_http/http_websocket.html#使用-http-不断轮询)\n\n[WebSocket 教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n\n[Localtunnel ~ Expose yourself to the world](https://localtunnel.github.io/www/)","slug":"websocket","published":1,"updated":"2024-06-28T08:47:40.316Z","comments":1,"layout":"post","photos":[],"_id":"clzuppnmv0003ytpz3kfz000a","content":"<p>最近工作上接触到了Websocket这个东西，由此引发了一系列的问题，写篇文章记录一下涉及的技术。</p>\n<h2 id=\"为什么有Websocket？\"><a href=\"#为什么有Websocket？\" class=\"headerlink\" title=\"为什么有Websocket？\"></a>为什么有Websocket？</h2><p>初见Websocket可能会联想到socket套接字，用我看到文章里的说法来解释两者的关系，大概就是雷锋和雷锋塔的关系，两者几乎没有关系。</p>\n<p>其实Wesocket是一个协议，属于应用层，提到应用层协议首先想到的是HTTP，对于我来说，我就只知道HTTP这一个应用层协议，既然有了HTTP，为什么还需要Websocket呢？</p>\n<p>因为HTTP有一个缺陷，通信只能由客户端发起。</p>\n<p>客户端发送请求后，服务器才能给客户端响应消息，这种单向性导致如果客户端要持续获得服务器的状态变化，就得每隔一段时间向服务器发送请求，这种方式称作轮询。</p>\n<p>轮询的弊端显而易见，需要额外的资源来进行轮询，即使服务器状态没有发生变化。</p>\n<p>众所周知，HTTP是基于TCP的，而TCP是全双工的，但HTTP是半双工的，这是因为HTTP起初是为看网页文本的场景设计的，没有考虑客户端和服务器之间需要大量互发数据。</p>\n<p>为了支持这种场景，就有了Websocket。</p>\n<h2 id=\"什么是Websocket\"><a href=\"#什么是Websocket\" class=\"headerlink\" title=\"什么是Websocket?\"></a>什么是Websocket?</h2><p>基于TCP的应用层协议，支持全双工通信，协议标识符是<code>ws</code>(加密的话是<code>wss</code>)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure>\n\n<p>其报文结构我就不细说（不太关心，也不太了解），可以讲讲连接建立的方式。</p>\n<p>首先肯定是通过TCP三次握手建立连接，然后使用HTTP协议进行通信，如果想要建立Websocket通信，在这次HTTP通信中，就会带上特殊header头，接着就会升级到Websocket协议。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Upgrade: WebSocket</span><br><span class=\"line\">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n //随机生成的 base64 码</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何搭建一个Websocket服务器\"><a href=\"#如何搭建一个Websocket服务器\" class=\"headerlink\" title=\"如何搭建一个Websocket服务器\"></a>如何搭建一个Websocket服务器</h2><p>工作需要，需要搭建一个Websocket服务器，在GPT帮助下也是易如反掌。</p>\n<ol>\n<li><p>安装Node.js</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install nodejs npm</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建服务器工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> websocket-server</span><br><span class=\"line\"><span class=\"built_in\">cd</span> websocket-server</span><br><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装ws库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install ws</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建服务器文件</p>\n<p>在你的项目目录中创建一个名为 server.js 的文件，并添加以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">WebSocket</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ws&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> wss = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>.<span class=\"title class_\">Server</span>(&#123; <span class=\"attr\">host</span>: <span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"attr\">port</span>: <span class=\"number\">8080</span> &#125;);</span><br><span class=\"line\">wss.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"keyword\">function</span> <span class=\"title function_\">connection</span>(<span class=\"params\">ws</span>) &#123;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Client connected&#x27;</span>);</span><br><span class=\"line\">ws.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"keyword\">function</span> <span class=\"title function_\">incoming</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;received: %s&#x27;</span>, message);</span><br><span class=\"line\"><span class=\"comment\">// Echo the message back to the client</span></span><br><span class=\"line\">ws.<span class=\"title function_\">send</span>(<span class=\"string\">`Echo: <span class=\"subst\">$&#123;message&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"keyword\">function</span> <span class=\"title function_\">close</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Client disconnected&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;WebSocket server is running&#x27;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node server.js</span><br></pre></td></tr></table></figure>\n\n<p>现在，你的WebSocket服务器应该在端口8080上运行。你可以使用任何支持WebSocket的客户端来连 接到这个服务器，例如WebSocket客户端或者浏览器。</p>\n</li>\n</ol>\n<h2 id=\"如何在公网上访问本地Websocket服务器\"><a href=\"#如何在公网上访问本地Websocket服务器\" class=\"headerlink\" title=\"如何在公网上访问本地Websocket服务器\"></a>如何在公网上访问本地Websocket服务器</h2><p>使用上述流程搭建的服务器是在本地的8080端口上，如何让其他人也能访问到你的服务器呢？</p>\n<p>当然可以搭建一个公网服务器，但是为了工作还要付出额外开销是不可能的，于是可以采用内网穿透的方式来解决这个问题。</p>\n<blockquote>\n<p>内网穿透，也称为NAT穿透，是一种网络技术，它允许位于私有网络（内网）中的计算机或设备上的服务可以被外部网络（如互联网）上的其他计算机访问。这通常用于绕过NAT（网络地址转换）和防火墙的限制，因为大多数家庭和小型办公室网络都使用NAT来共享一个公共IP地址。</p>\n</blockquote>\n<p>我们可以使用 <code>localtunnel </code>工具来实现内网穿透。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g localtunnel</span><br><span class=\"line\">lt -p 8080</span><br></pre></td></tr></table></figure>\n\n<p>-p 参数后面跟着你的本地服务器端口，运行后，会分配一个随机唯一的公网URL，如果想要固定的 URL，请使用 -s 参数，后面跟着你设置的域名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lt -p 8080 -s forwstest</span><br></pre></td></tr></table></figure>\n\n<p>GPT提示我说，这样方式暴露的服务器的安全性没法得到保障，很有可能被人反向工具，只建议测试使用。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://xiaolincoding.com/network/2_http/http_websocket.html#%E4%BD%BF%E7%94%A8-http-%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2\">3.9 既然有 HTTP 协议，为什么还要有 WebSocket？ | 小林coding (xiaolincoding.com)</a></p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2017/05/websocket.html\">WebSocket 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<p><a href=\"https://localtunnel.github.io/www/\">Localtunnel ~ Expose yourself to the world</a></p>\n","length":2235,"excerpt":"","more":"<p>最近工作上接触到了Websocket这个东西，由此引发了一系列的问题，写篇文章记录一下涉及的技术。</p>\n<h2 id=\"为什么有Websocket？\"><a href=\"#为什么有Websocket？\" class=\"headerlink\" title=\"为什么有Websocket？\"></a>为什么有Websocket？</h2><p>初见Websocket可能会联想到socket套接字，用我看到文章里的说法来解释两者的关系，大概就是雷锋和雷锋塔的关系，两者几乎没有关系。</p>\n<p>其实Wesocket是一个协议，属于应用层，提到应用层协议首先想到的是HTTP，对于我来说，我就只知道HTTP这一个应用层协议，既然有了HTTP，为什么还需要Websocket呢？</p>\n<p>因为HTTP有一个缺陷，通信只能由客户端发起。</p>\n<p>客户端发送请求后，服务器才能给客户端响应消息，这种单向性导致如果客户端要持续获得服务器的状态变化，就得每隔一段时间向服务器发送请求，这种方式称作轮询。</p>\n<p>轮询的弊端显而易见，需要额外的资源来进行轮询，即使服务器状态没有发生变化。</p>\n<p>众所周知，HTTP是基于TCP的，而TCP是全双工的，但HTTP是半双工的，这是因为HTTP起初是为看网页文本的场景设计的，没有考虑客户端和服务器之间需要大量互发数据。</p>\n<p>为了支持这种场景，就有了Websocket。</p>\n<h2 id=\"什么是Websocket\"><a href=\"#什么是Websocket\" class=\"headerlink\" title=\"什么是Websocket?\"></a>什么是Websocket?</h2><p>基于TCP的应用层协议，支持全双工通信，协议标识符是<code>ws</code>(加密的话是<code>wss</code>)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure>\n\n<p>其报文结构我就不细说（不太关心，也不太了解），可以讲讲连接建立的方式。</p>\n<p>首先肯定是通过TCP三次握手建立连接，然后使用HTTP协议进行通信，如果想要建立Websocket通信，在这次HTTP通信中，就会带上特殊header头，接着就会升级到Websocket协议。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Upgrade: WebSocket</span><br><span class=\"line\">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\\r\\n //随机生成的 base64 码</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何搭建一个Websocket服务器\"><a href=\"#如何搭建一个Websocket服务器\" class=\"headerlink\" title=\"如何搭建一个Websocket服务器\"></a>如何搭建一个Websocket服务器</h2><p>工作需要，需要搭建一个Websocket服务器，在GPT帮助下也是易如反掌。</p>\n<ol>\n<li><p>安装Node.js</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install nodejs npm</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建服务器工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> websocket-server</span><br><span class=\"line\"><span class=\"built_in\">cd</span> websocket-server</span><br><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装ws库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install ws</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建服务器文件</p>\n<p>在你的项目目录中创建一个名为 server.js 的文件，并添加以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">WebSocket</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;ws&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> wss = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>.<span class=\"title class_\">Server</span>(&#123; <span class=\"attr\">host</span>: <span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"attr\">port</span>: <span class=\"number\">8080</span> &#125;);</span><br><span class=\"line\">wss.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;connection&#x27;</span>, <span class=\"keyword\">function</span> <span class=\"title function_\">connection</span>(<span class=\"params\">ws</span>) &#123;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Client connected&#x27;</span>);</span><br><span class=\"line\">ws.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"keyword\">function</span> <span class=\"title function_\">incoming</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;received: %s&#x27;</span>, message);</span><br><span class=\"line\"><span class=\"comment\">// Echo the message back to the client</span></span><br><span class=\"line\">ws.<span class=\"title function_\">send</span>(<span class=\"string\">`Echo: <span class=\"subst\">$&#123;message&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"keyword\">function</span> <span class=\"title function_\">close</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Client disconnected&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;WebSocket server is running&#x27;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node server.js</span><br></pre></td></tr></table></figure>\n\n<p>现在，你的WebSocket服务器应该在端口8080上运行。你可以使用任何支持WebSocket的客户端来连 接到这个服务器，例如WebSocket客户端或者浏览器。</p>\n</li>\n</ol>\n<h2 id=\"如何在公网上访问本地Websocket服务器\"><a href=\"#如何在公网上访问本地Websocket服务器\" class=\"headerlink\" title=\"如何在公网上访问本地Websocket服务器\"></a>如何在公网上访问本地Websocket服务器</h2><p>使用上述流程搭建的服务器是在本地的8080端口上，如何让其他人也能访问到你的服务器呢？</p>\n<p>当然可以搭建一个公网服务器，但是为了工作还要付出额外开销是不可能的，于是可以采用内网穿透的方式来解决这个问题。</p>\n<blockquote>\n<p>内网穿透，也称为NAT穿透，是一种网络技术，它允许位于私有网络（内网）中的计算机或设备上的服务可以被外部网络（如互联网）上的其他计算机访问。这通常用于绕过NAT（网络地址转换）和防火墙的限制，因为大多数家庭和小型办公室网络都使用NAT来共享一个公共IP地址。</p>\n</blockquote>\n<p>我们可以使用 <code>localtunnel </code>工具来实现内网穿透。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g localtunnel</span><br><span class=\"line\">lt -p 8080</span><br></pre></td></tr></table></figure>\n\n<p>-p 参数后面跟着你的本地服务器端口，运行后，会分配一个随机唯一的公网URL，如果想要固定的 URL，请使用 -s 参数，后面跟着你设置的域名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lt -p 8080 -s forwstest</span><br></pre></td></tr></table></figure>\n\n<p>GPT提示我说，这样方式暴露的服务器的安全性没法得到保障，很有可能被人反向工具，只建议测试使用。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://xiaolincoding.com/network/2_http/http_websocket.html#%E4%BD%BF%E7%94%A8-http-%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2\">3.9 既然有 HTTP 协议，为什么还要有 WebSocket？ | 小林coding (xiaolincoding.com)</a></p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2017/05/websocket.html\">WebSocket 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<p><a href=\"https://localtunnel.github.io/www/\">Localtunnel ~ Expose yourself to the world</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clzuppnmq0000ytpzd8vi8uqs","tag_id":"clzuppnmu0002ytpzc7gybl5y","_id":"clzuppnmx0006ytpza0kd6ci2"},{"post_id":"clzuppnmq0000ytpzd8vi8uqs","tag_id":"clzuppnmw0004ytpz0zqkffqs","_id":"clzuppnmx0007ytpzgv577nwx"},{"post_id":"clzuppnmt0001ytpzdag2cwcv","tag_id":"clzuppnmu0002ytpzc7gybl5y","_id":"clzuppnmx000aytpz6eda9ki0"},{"post_id":"clzuppnmt0001ytpzdag2cwcv","tag_id":"clzuppnmx0008ytpzcjti8sn9","_id":"clzuppnmx000bytpzbrc41doq"},{"post_id":"clzuppnmv0003ytpz3kfz000a","tag_id":"clzuppnmx0009ytpz36x9ezfj","_id":"clzuppnmx000cytpz72qp7ujw"}],"Tag":[{"name":"C++","_id":"clzuppnmu0002ytpzc7gybl5y"},{"name":"C++11","_id":"clzuppnmw0004ytpz0zqkffqs"},{"name":"C++17","_id":"clzuppnmx0008ytpzcjti8sn9"},{"name":"计算机网络","_id":"clzuppnmx0009ytpz36x9ezfj"}]}}